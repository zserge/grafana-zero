{"version":3,"file":"lokiPlugin.07a78e2e5dfa22b54847.js","mappings":"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","sources":["webpack://grafana/./.yarn/cache/uuid-npm-8.3.0-2f98335399-b539886e6a.zip/node_modules/uuid/dist/esm-browser/parse.js","webpack://grafana/./.yarn/cache/uuid-npm-8.3.0-2f98335399-b539886e6a.zip/node_modules/uuid/dist/esm-browser/sha1.js","webpack://grafana/./.yarn/cache/uuid-npm-8.3.0-2f98335399-b539886e6a.zip/node_modules/uuid/dist/esm-browser/v5.js","webpack://grafana/./.yarn/cache/uuid-npm-8.3.0-2f98335399-b539886e6a.zip/node_modules/uuid/dist/esm-browser/v35.js","webpack://grafana/./public/app/plugins/datasource/loki/query_utils.ts","webpack://grafana/./public/app/plugins/datasource/loki/types.ts","webpack://grafana/./public/app/plugins/datasource/loki/result_transformer.ts","webpack://grafana/./.yarn/cache/rxjs-npm-7.3.0-8a14d1c3d9-e63adb8808.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/WebSocketSubject.js","webpack://grafana/./public/app/plugins/datasource/loki/live_streams.ts","webpack://grafana/./.yarn/cache/rxjs-npm-7.3.0-8a14d1c3d9-e63adb8808.zip/node_modules/rxjs/dist/esm5/internal/observable/dom/webSocket.js","webpack://grafana/./public/app/plugins/datasource/loki/importing/fromGraphite.ts","webpack://grafana/./public/app/plugins/datasource/loki/language_provider.ts","webpack://grafana/./public/app/plugins/datasource/loki/datasource.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiCheatSheet.tsx","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiExploreQueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiQueryEditorForAlerting.tsx","webpack://grafana/./public/app/plugins/datasource/loki/components/LokiQueryEditorByApp.tsx","webpack://grafana/./public/app/plugins/datasource/loki/LokiAnnotationsQueryCtrl.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/MaxLinesField.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/DerivedField.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/DebugSection.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/DerivedFields.tsx","webpack://grafana/./public/app/plugins/datasource/loki/configuration/ConfigEditor.tsx","webpack://grafana/./public/app/plugins/datasource/loki/module.ts"],"sourcesContent":["import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  var v;\n  var arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n\n    M[_i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nvar v5 = v35('v5', 0x50, sha1);\nexport default v5;","import stringify from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return stringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","import { escapeRegExp } from 'lodash';\nimport { PIPE_PARSERS } from './syntax';\n\nexport function formatQuery(selector: string | undefined): string {\n  return `${selector || ''}`.trim();\n}\n\n/**\n * Returns search terms from a LogQL query.\n * E.g., `{} |= foo |=bar != baz` returns `['foo', 'bar']`.\n */\nexport function getHighlighterExpressionsFromQuery(input: string): string[] {\n  let expression = input;\n  const results = [];\n\n  // Consume filter expression from left to right\n  while (expression) {\n    const filterStart = expression.search(/\\|=|\\|~|!=|!~/);\n    // Nothing more to search\n    if (filterStart === -1) {\n      break;\n    }\n    // Drop terms for negative filters\n    const filterOperator = expression.substr(filterStart, 2);\n    const skip = expression.substr(filterStart).search(/!=|!~/) === 0;\n    expression = expression.substr(filterStart + 2);\n    if (skip) {\n      continue;\n    }\n    // Check if there is more chained\n    const filterEnd = expression.search(/\\|=|\\|~|!=|!~/);\n    let filterTerm;\n    if (filterEnd === -1) {\n      filterTerm = expression.trim();\n    } else {\n      filterTerm = expression.substr(0, filterEnd).trim();\n      expression = expression.substr(filterEnd);\n    }\n\n    const quotedTerm = filterTerm.match(/\"(.*?)\"/);\n    const backtickedTerm = filterTerm.match(/`(.*?)`/);\n    const term = quotedTerm || backtickedTerm;\n\n    if (term) {\n      const unwrappedFilterTerm = term[1];\n      const regexOperator = filterOperator === '|~';\n\n      // Only filter expressions with |~ operator are treated as regular expressions\n      if (regexOperator) {\n        // When using backticks, Loki doesn't require to escape special characters and we can just push regular expression to highlights array\n        // When using quotes, we have extra backslash escaping and we need to replace \\\\ with \\\n        results.push(backtickedTerm ? unwrappedFilterTerm : unwrappedFilterTerm.replace(/\\\\\\\\/g, '\\\\'));\n      } else {\n        // We need to escape this string so it is not matched as regular expression\n        results.push(escapeRegExp(unwrappedFilterTerm));\n      }\n    } else {\n      return results;\n    }\n  }\n\n  return results;\n}\n\nexport function queryHasPipeParser(expr: string): boolean {\n  const parsers = PIPE_PARSERS.map((parser) => `${parser.label}`).join('|');\n  const regexp = new RegExp(`\\\\\\|\\\\\\s?(${parsers})`);\n  return regexp.test(expr);\n}\n\nexport function addParsedLabelToQuery(expr: string, key: string, value: string | number, operator: string) {\n  return expr + ` | ${key}${operator}\"${value.toString()}\"`;\n}\n","import { DataQuery, DataSourceJsonData, QueryResultMeta, ScopedVars } from '@grafana/data';\n\nexport interface LokiInstantQueryRequest {\n  query: string;\n  limit?: number;\n  time?: string;\n  direction?: 'BACKWARD' | 'FORWARD';\n}\n\nexport interface LokiRangeQueryRequest {\n  query: string;\n  limit?: number;\n  start?: number;\n  end?: number;\n  step?: number;\n  direction?: 'BACKWARD' | 'FORWARD';\n}\n\nexport enum LokiResultType {\n  Stream = 'streams',\n  Vector = 'vector',\n  Matrix = 'matrix',\n}\n\nexport interface LokiQuery extends DataQuery {\n  expr: string;\n  query?: string;\n  format?: string;\n  reverse?: boolean;\n  legendFormat?: string;\n  valueWithRefId?: boolean;\n  maxLines?: number;\n  resolution?: number;\n  range?: boolean;\n  instant?: boolean;\n  volumeQuery?: boolean;\n}\n\nexport interface LokiOptions extends DataSourceJsonData {\n  maxLines?: string;\n  derivedFields?: DerivedFieldConfig[];\n  alertmanager?: string;\n}\n\nexport interface LokiStats {\n  [component: string]: {\n    [label: string]: number;\n  };\n}\n\nexport interface LokiVectorResult {\n  metric: { [label: string]: string };\n  value: [number, string];\n}\n\nexport interface LokiVectorResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Vector;\n    result: LokiVectorResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiMatrixResult {\n  metric: Record<string, string>;\n  values: Array<[number, string]>;\n}\n\nexport interface LokiMatrixResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Matrix;\n    result: LokiMatrixResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiStreamResult {\n  stream: Record<string, string>;\n  values: Array<[string, string]>;\n}\n\nexport interface LokiStreamResponse {\n  status: string;\n  data: {\n    resultType: LokiResultType.Stream;\n    result: LokiStreamResult[];\n    stats?: LokiStats;\n  };\n}\n\nexport interface LokiTailResponse {\n  streams: LokiStreamResult[];\n  dropped_entries?: Array<{\n    labels: Record<string, string>;\n    timestamp: string;\n  }> | null;\n}\n\nexport type LokiResult = LokiVectorResult | LokiMatrixResult | LokiStreamResult;\nexport type LokiResponse = LokiVectorResponse | LokiMatrixResponse | LokiStreamResponse;\n\nexport interface LokiLogsStreamEntry {\n  line: string;\n  ts: string;\n}\n\nexport interface LokiExpression {\n  regexp: string;\n  query: string;\n}\n\nexport type DerivedFieldConfig = {\n  matcherRegex: string;\n  name: string;\n  url?: string;\n  urlDisplayLabel?: string;\n  datasourceUid?: string;\n};\n\nexport interface TransformerOptions {\n  format?: string;\n  legendFormat?: string;\n  step: number;\n  start: number;\n  end: number;\n  query: string;\n  responseListLength: number;\n  refId: string;\n  scopedVars: ScopedVars;\n  meta?: QueryResultMeta;\n  valueWithRefId?: boolean;\n}\n","import { capitalize, groupBy, isEmpty } from 'lodash';\nimport { v5 as uuidv5 } from 'uuid';\nimport { of } from 'rxjs';\n\nimport {\n  FieldType,\n  TimeSeries,\n  Labels,\n  DataFrame,\n  ArrayVector,\n  MutableDataFrame,\n  findUniqueLabels,\n  DataFrameView,\n  DataLink,\n  Field,\n  QueryResultMetaStat,\n  QueryResultMeta,\n  TimeSeriesValue,\n  ScopedVars,\n} from '@grafana/data';\n\nimport { getTemplateSrv, getDataSourceSrv } from '@grafana/runtime';\nimport TableModel from 'app/core/table_model';\nimport { formatQuery, getHighlighterExpressionsFromQuery } from './query_utils';\nimport {\n  LokiRangeQueryRequest,\n  LokiResponse,\n  LokiMatrixResult,\n  LokiVectorResult,\n  TransformerOptions,\n  LokiResultType,\n  LokiStreamResult,\n  LokiTailResponse,\n  LokiQuery,\n  LokiOptions,\n  DerivedFieldConfig,\n  LokiStreamResponse,\n  LokiStats,\n} from './types';\n\nconst UUID_NAMESPACE = '6ec946da-0f49-47a8-983a-1d76d17e7c92';\n\n/**\n * Transforms LokiStreamResult structure into a dataFrame. Used when doing standard queries and newer version of Loki.\n */\nexport function lokiStreamResultToDataFrame(stream: LokiStreamResult, reverse?: boolean, refId?: string): DataFrame {\n  const labels: Labels = stream.stream;\n  const labelsString = Object.entries(labels)\n    .map(([key, val]) => `${key}=\"${val}\"`)\n    .sort()\n    .join('');\n\n  const times = new ArrayVector<string>([]);\n  const timesNs = new ArrayVector<string>([]);\n  const lines = new ArrayVector<string>([]);\n  const uids = new ArrayVector<string>([]);\n\n  // We need to store and track all used uids to ensure that uids are unique\n  const usedUids: { string?: number } = {};\n\n  for (const [ts, line] of stream.values) {\n    // num ns epoch in string, we convert it to iso string here so it matches old format\n    times.add(new Date(parseInt(ts.substr(0, ts.length - 6), 10)).toISOString());\n    timesNs.add(ts);\n    lines.add(line);\n    uids.add(createUid(ts, labelsString, line, usedUids, refId));\n  }\n\n  return constructDataFrame(times, timesNs, lines, uids, labels, reverse, refId);\n}\n\n/**\n * Constructs dataFrame with supplied fields and other data. Also makes sure it is properly reversed if needed.\n */\nfunction constructDataFrame(\n  times: ArrayVector<string>,\n  timesNs: ArrayVector<string>,\n  lines: ArrayVector<string>,\n  uids: ArrayVector<string>,\n  labels: Labels,\n  reverse?: boolean,\n  refId?: string\n) {\n  const dataFrame = {\n    refId,\n    fields: [\n      { name: 'ts', type: FieldType.time, config: { displayName: 'Time' }, values: times }, // Time\n      { name: 'line', type: FieldType.string, config: {}, values: lines, labels }, // Line - needs to be the first field with string type\n      { name: 'id', type: FieldType.string, config: {}, values: uids },\n      { name: 'tsNs', type: FieldType.time, config: { displayName: 'Time ns' }, values: timesNs }, // Time\n    ],\n    length: times.length,\n  };\n\n  if (reverse) {\n    const mutableDataFrame = new MutableDataFrame(dataFrame);\n    mutableDataFrame.reverse();\n    return mutableDataFrame;\n  }\n\n  return dataFrame;\n}\n\n/**\n * Transform LokiResponse data and appends it to MutableDataFrame. Used for streaming where the dataFrame can be\n * a CircularDataFrame creating a fixed size rolling buffer.\n * TODO: Probably could be unified with the logStreamToDataFrame function.\n * @param response\n * @param data Needs to have ts, line, labels, id as fields\n */\nexport function appendResponseToBufferedData(response: LokiTailResponse, data: MutableDataFrame) {\n  // Should we do anything with: response.dropped_entries?\n\n  const streams: LokiStreamResult[] = response.streams;\n  if (!streams || !streams.length) {\n    return;\n  }\n\n  let baseLabels: Labels = {};\n  for (const f of data.fields) {\n    if (f.type === FieldType.string) {\n      if (f.labels) {\n        baseLabels = f.labels;\n      }\n      break;\n    }\n  }\n\n  const tsField = data.fields[0];\n  const tsNsField = data.fields[1];\n  const lineField = data.fields[2];\n  const labelsField = data.fields[3];\n  const idField = data.fields[4];\n\n  // We are comparing used ids only within the received stream. This could be a problem if the same line + labels + nanosecond timestamp came in 2 separate batches.\n  // As this is very unlikely, and the result would only affect live-tailing css animation we have decided to not compare all received uids from data param as this would slow down processing.\n  const usedUids: { string?: number } = {};\n\n  for (const stream of streams) {\n    // Find unique labels\n    const unique = findUniqueLabels(stream.stream, baseLabels);\n    const allLabelsString = Object.entries(stream.stream)\n      .map(([key, val]) => `${key}=\"${val}\"`)\n      .sort()\n      .join('');\n\n    // Add each line\n    for (const [ts, line] of stream.values) {\n      tsField.values.add(new Date(parseInt(ts.substr(0, ts.length - 6), 10)).toISOString());\n      tsNsField.values.add(ts);\n      lineField.values.add(line);\n      labelsField.values.add(unique);\n      idField.values.add(createUid(ts, allLabelsString, line, usedUids, data.refId));\n    }\n  }\n}\n\nfunction createUid(ts: string, labelsString: string, line: string, usedUids: any, refId?: string): string {\n  // Generate id as hashed nanosecond timestamp, labels and line (this does not have to be unique)\n  let id = uuidv5(`${ts}_${labelsString}_${line}`, UUID_NAMESPACE);\n\n  // Check if generated id is unique\n  // If not and we've already used it, append it's count after it\n  if (id in usedUids) {\n    // Increase the count\n    const newCount = usedUids[id] + 1;\n    usedUids[id] = newCount;\n    // Append count to generated id to make it unique\n    id = `${id}_${newCount}`;\n  } else {\n    // If id is unique and wasn't used, add it to usedUids and start count at 0\n    usedUids[id] = 0;\n  }\n  // Return unique id\n  if (refId) {\n    return `${id}_${refId}`;\n  }\n  return id;\n}\n\nfunction lokiMatrixToTimeSeries(matrixResult: LokiMatrixResult, options: TransformerOptions): TimeSeries {\n  const name = createMetricLabel(matrixResult.metric, options);\n  return {\n    target: name,\n    title: name,\n    datapoints: lokiPointsToTimeseriesPoints(matrixResult.values, options),\n    tags: matrixResult.metric,\n    meta: options.meta,\n    refId: options.refId,\n  };\n}\n\nexport function lokiPointsToTimeseriesPoints(\n  data: Array<[number, string]>,\n  options: TransformerOptions\n): TimeSeriesValue[][] {\n  const stepMs = options.step * 1000;\n  const datapoints: TimeSeriesValue[][] = [];\n\n  let baseTimestampMs = options.start / 1e6;\n  for (const [time, value] of data) {\n    let datapointValue: TimeSeriesValue = parseFloat(value);\n\n    if (isNaN(datapointValue)) {\n      datapointValue = null;\n    }\n\n    const timestamp = time * 1000;\n    for (let t = baseTimestampMs; t < timestamp; t += stepMs) {\n      datapoints.push([null, t]);\n    }\n\n    baseTimestampMs = timestamp + stepMs;\n    datapoints.push([datapointValue, timestamp]);\n  }\n\n  const endTimestamp = options.end / 1e6;\n  for (let t = baseTimestampMs; t <= endTimestamp; t += stepMs) {\n    datapoints.push([null, t]);\n  }\n\n  return datapoints;\n}\n\nexport function lokiResultsToTableModel(\n  lokiResults: Array<LokiMatrixResult | LokiVectorResult>,\n  resultCount: number,\n  refId: string,\n  meta: QueryResultMeta,\n  valueWithRefId?: boolean\n): TableModel {\n  if (!lokiResults || lokiResults.length === 0) {\n    return new TableModel();\n  }\n\n  // Collect all labels across all metrics\n  const metricLabels: Set<string> = new Set<string>(\n    lokiResults.reduce((acc, cur) => acc.concat(Object.keys(cur.metric)), [] as string[])\n  );\n\n  // Sort metric labels, create columns for them and record their index\n  const sortedLabels = [...metricLabels.values()].sort();\n  const table = new TableModel();\n  table.refId = refId;\n  table.meta = meta;\n  table.columns = [\n    { text: 'Time', type: FieldType.time },\n    ...sortedLabels.map((label) => ({ text: label, filterable: true, type: FieldType.string })),\n    { text: resultCount > 1 || valueWithRefId ? `Value #${refId}` : 'Value', type: FieldType.number },\n  ];\n\n  // Populate rows, set value to empty string when label not present.\n  lokiResults.forEach((series) => {\n    const newSeries: LokiMatrixResult = {\n      metric: series.metric,\n      values: (series as LokiVectorResult).value\n        ? [(series as LokiVectorResult).value]\n        : (series as LokiMatrixResult).values,\n    };\n\n    if (!newSeries.values) {\n      return;\n    }\n\n    if (!newSeries.metric) {\n      table.rows.concat(newSeries.values.map(([a, b]) => [a * 1000, parseFloat(b)]));\n    } else {\n      table.rows.push(\n        ...newSeries.values.map(([a, b]) => [\n          a * 1000,\n          ...sortedLabels.map((label) => newSeries.metric[label] || ''),\n          parseFloat(b),\n        ])\n      );\n    }\n  });\n\n  return table;\n}\n\nexport function createMetricLabel(labelData: { [key: string]: string }, options?: TransformerOptions) {\n  let label =\n    options === undefined || isEmpty(options.legendFormat)\n      ? getOriginalMetricName(labelData)\n      : renderTemplate(getTemplateSrv().replace(options.legendFormat ?? '', options.scopedVars), labelData);\n\n  if (!label && options) {\n    label = options.query;\n  }\n  return label;\n}\n\nfunction renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_, g1) => (aliasData[g1] ? aliasData[g1] : g1));\n}\n\nfunction getOriginalMetricName(labelData: { [key: string]: string }) {\n  const metricName = labelData.__name__ || '';\n  delete labelData.__name__;\n  const labelPart = Object.entries(labelData)\n    .map((label) => `${label[0]}=\"${label[1]}\"`)\n    .join(',');\n  return `${metricName}{${labelPart}}`;\n}\n\nexport function decamelize(s: string): string {\n  return s.replace(/[A-Z]/g, (m) => ` ${m.toLowerCase()}`);\n}\n\n// Turn loki stats { metric: value } into meta stat { title: metric, value: value }\nfunction lokiStatsToMetaStat(stats: LokiStats | undefined): QueryResultMetaStat[] {\n  const result: QueryResultMetaStat[] = [];\n\n  if (!stats) {\n    return result;\n  }\n\n  for (const section in stats) {\n    const values = stats[section];\n    for (const label in values) {\n      const value = values[label];\n      let unit;\n      if (/time/i.test(label) && value) {\n        unit = 's';\n      } else if (/bytes.*persecond/i.test(label)) {\n        unit = 'Bps';\n      } else if (/bytes/i.test(label)) {\n        unit = 'decbytes';\n      }\n      const title = `${capitalize(section)}: ${decamelize(label)}`;\n      result.push({ displayName: title, value, unit });\n    }\n  }\n\n  return result;\n}\n\nexport function lokiStreamsToDataFrames(\n  response: LokiStreamResponse,\n  target: { refId: string; expr?: string },\n  limit: number,\n  config: LokiOptions,\n  reverse = false\n): DataFrame[] {\n  const data = limit > 0 ? response.data.result : [];\n  const stats: QueryResultMetaStat[] = lokiStatsToMetaStat(response.data.stats);\n  // Use custom mechanism to identify which stat we want to promote to label\n  const custom = {\n    lokiQueryStatKey: 'Summary: total bytes processed',\n  };\n\n  const meta: QueryResultMeta = {\n    searchWords: getHighlighterExpressionsFromQuery(formatQuery(target.expr)),\n    limit,\n    stats,\n    custom,\n    preferredVisualisationType: 'logs',\n  };\n\n  const series: DataFrame[] = data.map((stream) => {\n    const dataFrame = lokiStreamResultToDataFrame(stream, reverse, target.refId);\n    enhanceDataFrame(dataFrame, config);\n\n    if (meta.custom && dataFrame.fields.some((f) => f.labels && Object.keys(f.labels).some((l) => l === '__error__'))) {\n      meta.custom.error = 'Error when parsing some of the logs';\n    }\n\n    return {\n      ...dataFrame,\n      refId: target.refId,\n      meta,\n    };\n  });\n\n  if (stats.length && !data.length) {\n    return [\n      {\n        fields: [],\n        length: 0,\n        refId: target.refId,\n        meta,\n      },\n    ];\n  }\n\n  return series;\n}\n\n/**\n * Adds new fields and DataLinks to DataFrame based on DataSource instance config.\n */\nexport const enhanceDataFrame = (dataFrame: DataFrame, config: LokiOptions | null): void => {\n  if (!config) {\n    return;\n  }\n\n  const derivedFields = config.derivedFields ?? [];\n  if (!derivedFields.length) {\n    return;\n  }\n  const derivedFieldsGrouped = groupBy(derivedFields, 'name');\n\n  const newFields = Object.values(derivedFieldsGrouped).map(fieldFromDerivedFieldConfig);\n\n  const view = new DataFrameView(dataFrame);\n  view.forEach((row: { line: string }) => {\n    for (const field of newFields) {\n      const logMatch = row.line.match(derivedFieldsGrouped[field.name][0].matcherRegex);\n      field.values.add(logMatch && logMatch[1]);\n    }\n  });\n\n  dataFrame.fields = [...dataFrame.fields, ...newFields];\n};\n\n/**\n * Transform derivedField config into dataframe field with config that contains link.\n */\nfunction fieldFromDerivedFieldConfig(derivedFieldConfigs: DerivedFieldConfig[]): Field<any, ArrayVector> {\n  const dataSourceSrv = getDataSourceSrv();\n\n  const dataLinks = derivedFieldConfigs.reduce((acc, derivedFieldConfig) => {\n    // Having field.datasourceUid means it is an internal link.\n    if (derivedFieldConfig.datasourceUid) {\n      const dsSettings = dataSourceSrv.getInstanceSettings(derivedFieldConfig.datasourceUid);\n\n      acc.push({\n        // Will be filled out later\n        title: derivedFieldConfig.urlDisplayLabel || '',\n        url: '',\n        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object\n        internal: {\n          query: { query: derivedFieldConfig.url },\n          datasourceUid: derivedFieldConfig.datasourceUid,\n          datasourceName: dsSettings?.name ?? 'Data source not found',\n        },\n      });\n    } else if (derivedFieldConfig.url) {\n      acc.push({\n        // We do not know what title to give here so we count on presentation layer to create a title from metadata.\n        title: derivedFieldConfig.urlDisplayLabel || '',\n        // This is hardcoded for Jaeger or Zipkin not way right now to specify datasource specific query object\n        url: derivedFieldConfig.url,\n      });\n    }\n    return acc;\n  }, [] as DataLink[]);\n\n  return {\n    name: derivedFieldConfigs[0].name,\n    type: FieldType.string,\n    config: {\n      links: dataLinks,\n    },\n    // We are adding values later on\n    values: new ArrayVector<string>([]),\n  };\n}\n\nexport function rangeQueryResponseToTimeSeries(\n  response: LokiResponse,\n  query: LokiRangeQueryRequest,\n  target: LokiQuery,\n  responseListLength: number,\n  scopedVars: ScopedVars\n): TimeSeries[] {\n  /** Show results of Loki metric queries only in graph */\n  const meta: QueryResultMeta = {\n    preferredVisualisationType: 'graph',\n  };\n  const transformerOptions: TransformerOptions = {\n    format: target.format,\n    legendFormat: target.legendFormat ?? '',\n    start: query.start!,\n    end: query.end!,\n    step: query.step!,\n    query: query.query,\n    responseListLength,\n    refId: target.refId,\n    meta,\n    valueWithRefId: target.valueWithRefId,\n    scopedVars,\n  };\n\n  switch (response.data.resultType) {\n    case LokiResultType.Vector:\n      return response.data.result.map((vecResult) =>\n        lokiMatrixToTimeSeries({ metric: vecResult.metric, values: [vecResult.value] }, transformerOptions)\n      );\n    case LokiResultType.Matrix:\n      return response.data.result.map((matrixResult) => lokiMatrixToTimeSeries(matrixResult, transformerOptions));\n    default:\n      return [];\n  }\n}\n\nexport function processRangeQueryResponse(\n  response: LokiResponse,\n  target: LokiQuery,\n  query: LokiRangeQueryRequest,\n  responseListLength: number,\n  limit: number,\n  config: LokiOptions,\n  scopedVars: ScopedVars,\n  reverse = false\n) {\n  switch (response.data.resultType) {\n    case LokiResultType.Stream:\n      return of({\n        data: lokiStreamsToDataFrames(response as LokiStreamResponse, target, limit, config, reverse),\n        key: `${target.refId}_log`,\n      });\n\n    case LokiResultType.Vector:\n    case LokiResultType.Matrix:\n      return of({\n        data: rangeQueryResponseToTimeSeries(\n          response,\n          query,\n          {\n            ...target,\n            format: 'time_series',\n          },\n          responseListLength,\n          scopedVars\n        ),\n        key: target.refId,\n      });\n    default:\n      throw new Error(`Unknown result type \"${(response.data as any).resultType}\".`);\n  }\n}\n","import { __assign, __extends } from \"tslib\";\nimport { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { ReplaySubject } from '../../ReplaySubject';\nvar DEFAULT_WEBSOCKET_CONFIG = {\n    url: '',\n    deserializer: function (e) { return JSON.parse(e.data); },\n    serializer: function (value) { return JSON.stringify(value); },\n};\nvar WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';\nvar WebSocketSubject = (function (_super) {\n    __extends(WebSocketSubject, _super);\n    function WebSocketSubject(urlConfigOrSource, destination) {\n        var _this = _super.call(this) || this;\n        _this._socket = null;\n        if (urlConfigOrSource instanceof Observable) {\n            _this.destination = destination;\n            _this.source = urlConfigOrSource;\n        }\n        else {\n            var config = (_this._config = __assign({}, DEFAULT_WEBSOCKET_CONFIG));\n            _this._output = new Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                config.url = urlConfigOrSource;\n            }\n            else {\n                for (var key in urlConfigOrSource) {\n                    if (urlConfigOrSource.hasOwnProperty(key)) {\n                        config[key] = urlConfigOrSource[key];\n                    }\n                }\n            }\n            if (!config.WebSocketCtor && WebSocket) {\n                config.WebSocketCtor = WebSocket;\n            }\n            else if (!config.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            _this.destination = new ReplaySubject();\n        }\n        return _this;\n    }\n    WebSocketSubject.prototype.lift = function (operator) {\n        var sock = new WebSocketSubject(this._config, this.destination);\n        sock.operator = operator;\n        sock.source = this;\n        return sock;\n    };\n    WebSocketSubject.prototype._resetState = function () {\n        this._socket = null;\n        if (!this.source) {\n            this.destination = new ReplaySubject();\n        }\n        this._output = new Subject();\n    };\n    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n        var self = this;\n        return new Observable(function (observer) {\n            try {\n                self.next(subMsg());\n            }\n            catch (err) {\n                observer.error(err);\n            }\n            var subscription = self.subscribe(function (x) {\n                try {\n                    if (messageFilter(x)) {\n                        observer.next(x);\n                    }\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });\n            return function () {\n                try {\n                    self.next(unsubMsg());\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    };\n    WebSocketSubject.prototype._connectSocket = function () {\n        var _this = this;\n        var _a = this._config, WebSocketCtor = _a.WebSocketCtor, protocol = _a.protocol, url = _a.url, binaryType = _a.binaryType;\n        var observer = this._output;\n        var socket = null;\n        try {\n            socket = protocol ? new WebSocketCtor(url, protocol) : new WebSocketCtor(url);\n            this._socket = socket;\n            if (binaryType) {\n                this._socket.binaryType = binaryType;\n            }\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        var subscription = new Subscription(function () {\n            _this._socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = function (evt) {\n            var _socket = _this._socket;\n            if (!_socket) {\n                socket.close();\n                _this._resetState();\n                return;\n            }\n            var openObserver = _this._config.openObserver;\n            if (openObserver) {\n                openObserver.next(evt);\n            }\n            var queue = _this.destination;\n            _this.destination = Subscriber.create(function (x) {\n                if (socket.readyState === 1) {\n                    try {\n                        var serializer = _this._config.serializer;\n                        socket.send(serializer(x));\n                    }\n                    catch (e) {\n                        _this.destination.error(e);\n                    }\n                }\n            }, function (err) {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (err && err.code) {\n                    socket.close(err.code, err.reason);\n                }\n                else {\n                    observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));\n                }\n                _this._resetState();\n            }, function () {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                _this._resetState();\n            });\n            if (queue && queue instanceof ReplaySubject) {\n                subscription.add(queue.subscribe(_this.destination));\n            }\n        };\n        socket.onerror = function (e) {\n            _this._resetState();\n            observer.error(e);\n        };\n        socket.onclose = function (e) {\n            _this._resetState();\n            var closeObserver = _this._config.closeObserver;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = function (e) {\n            try {\n                var deserializer = _this._config.deserializer;\n                observer.next(deserializer(e));\n            }\n            catch (err) {\n                observer.error(err);\n            }\n        };\n    };\n    WebSocketSubject.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var source = this.source;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this._socket) {\n            this._connectSocket();\n        }\n        this._output.subscribe(subscriber);\n        subscriber.add(function () {\n            var _socket = _this._socket;\n            if (_this._output.observers.length === 0) {\n                if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {\n                    _socket.close();\n                }\n                _this._resetState();\n            }\n        });\n        return subscriber;\n    };\n    WebSocketSubject.prototype.unsubscribe = function () {\n        var _socket = this._socket;\n        if (_socket && (_socket.readyState === 1 || _socket.readyState === 0)) {\n            _socket.close();\n        }\n        this._resetState();\n        _super.prototype.unsubscribe.call(this);\n    };\n    return WebSocketSubject;\n}(AnonymousSubject));\nexport { WebSocketSubject };\n//# sourceMappingURL=WebSocketSubject.js.map","import { DataFrame, FieldType, parseLabels, KeyValue, CircularDataFrame } from '@grafana/data';\nimport { Observable, throwError, timer } from 'rxjs';\nimport { webSocket } from 'rxjs/webSocket';\nimport { LokiTailResponse } from './types';\nimport { finalize, map, retryWhen, mergeMap } from 'rxjs/operators';\nimport { appendResponseToBufferedData } from './result_transformer';\n\n/**\n * Maps directly to a query in the UI (refId is key)\n */\nexport interface LokiLiveTarget {\n  query: string;\n  url: string;\n  refId: string;\n  size: number;\n}\n\n/**\n * Cache of websocket streams that can be returned as observable. In case there already is a stream for particular\n * target it is returned and on subscription returns the latest dataFrame.\n */\nexport class LiveStreams {\n  private streams: KeyValue<Observable<DataFrame[]>> = {};\n\n  getStream(target: LokiLiveTarget, retryInterval = 5000): Observable<DataFrame[]> {\n    let stream = this.streams[target.url];\n\n    if (stream) {\n      return stream;\n    }\n\n    const data = new CircularDataFrame({ capacity: target.size });\n    data.addField({ name: 'ts', type: FieldType.time, config: { displayName: 'Time' } });\n    data.addField({ name: 'tsNs', type: FieldType.time, config: { displayName: 'Time ns' } });\n    data.addField({ name: 'line', type: FieldType.string }).labels = parseLabels(target.query);\n    data.addField({ name: 'labels', type: FieldType.other }); // The labels for each line\n    data.addField({ name: 'id', type: FieldType.string });\n    data.meta = { ...data.meta, preferredVisualisationType: 'logs' };\n    data.refId = target.refId;\n\n    stream = webSocket<LokiTailResponse>(target.url).pipe(\n      map((response: LokiTailResponse) => {\n        appendResponseToBufferedData(response, data);\n        return [data];\n      }),\n      retryWhen((attempts: Observable<any>) =>\n        attempts.pipe(\n          mergeMap((error, i) => {\n            const retryAttempt = i + 1;\n            // Code 1006 is used to indicate that a connection was closed abnormally.\n            // Added hard limit of 30 on number of retries.\n            // If connection was closed abnormally, and we wish to retry, otherwise throw error.\n            if (error.code === 1006 && retryAttempt < 30) {\n              if (retryAttempt > 10) {\n                // If more than 10 times retried, consol.warn, but keep reconnecting\n                console.warn(\n                  `Websocket connection is being disrupted. We keep reconnecting but consider starting new live tailing again. Error: ${error.reason}`\n                );\n              }\n              // Retry every 5s\n              return timer(retryInterval);\n            }\n            return throwError(error);\n          })\n        )\n      ),\n      finalize(() => {\n        delete this.streams[target.url];\n      })\n    );\n    this.streams[target.url] = stream;\n\n    return stream;\n  }\n}\n","import { WebSocketSubject } from './WebSocketSubject';\nexport function webSocket(urlConfigOrSource) {\n    return new WebSocketSubject(urlConfigOrSource);\n}\n//# sourceMappingURL=webSocket.js.map","import { default as GraphiteQueryModel } from '../../graphite/graphite_query';\nimport { map } from 'lodash';\nimport { LokiQuery } from '../types';\nimport { GraphiteDatasource } from '../../graphite/datasource';\nimport { getTemplateSrv } from '../../../../features/templating/template_srv';\nimport { GraphiteMetricLokiMatcher, GraphiteQuery, GraphiteToLokiQueryImportConfiguration } from '../../graphite/types';\n\nconst GRAPHITE_TO_LOKI_OPERATOR = {\n  '=': '=',\n  '!=': '!=',\n  '=~': '=~',\n  '!=~': '!~',\n};\n\n/**\n * Converts Graphite glob-like pattern to a regular expression\n */\nfunction convertGlobToRegEx(text: string): string {\n  if (text.includes('*') || text.includes('{')) {\n    return '^' + text.replace(/\\*/g, '.*').replace(/\\{/g, '(').replace(/}/g, ')').replace(/,/g, '|');\n  } else {\n    return text;\n  }\n}\n\nexport default function fromGraphiteQueries(\n  graphiteQueries: GraphiteQuery[],\n  graphiteDataSource: GraphiteDatasource\n): LokiQuery[] {\n  return graphiteQueries.map((query) => {\n    const model: GraphiteQueryModel = new GraphiteQueryModel(\n      graphiteDataSource,\n      {\n        ...query,\n        target: query.target || '',\n        textEditor: false,\n      },\n      getTemplateSrv()\n    );\n    model.parseTarget();\n\n    return {\n      refId: query.refId,\n      expr: fromGraphite(model, graphiteDataSource.getImportQueryConfiguration().loki),\n    };\n  });\n}\n\nfunction fromGraphite(graphiteQuery: GraphiteQueryModel, config: GraphiteToLokiQueryImportConfiguration): string {\n  let matchingFound = false;\n  let labels: any = {};\n\n  if (graphiteQuery.seriesByTagUsed) {\n    matchingFound = true;\n    graphiteQuery.tags.forEach((tag) => {\n      labels[tag.key] = {\n        value: tag.value,\n        operator: GRAPHITE_TO_LOKI_OPERATOR[tag.operator],\n      };\n    });\n  } else {\n    const targetNodes = graphiteQuery.segments.map((segment) => segment.value);\n    let mappings = config.mappings.filter((mapping) => mapping.matchers.length <= targetNodes.length);\n\n    for (let mapping of mappings) {\n      const matchers = mapping.matchers.concat();\n\n      matchingFound = matchers.every((matcher: GraphiteMetricLokiMatcher, index: number) => {\n        if (matcher.labelName) {\n          let value = (targetNodes[index] as string)!;\n\n          if (value === '*') {\n            return true;\n          }\n\n          const converted = convertGlobToRegEx(value);\n          labels[matcher.labelName] = {\n            value: converted,\n            operator: converted !== value ? '=~' : '=',\n          };\n\n          return true;\n        }\n        return targetNodes[index] === matcher.value || matcher.value === '*';\n      });\n    }\n  }\n\n  let pairs = map(labels, (value, key) => `${key}${value.operator}\"${value.value}\"`);\n  if (matchingFound && pairs.length) {\n    return `{${pairs.join(', ')}}`;\n  } else {\n    return '';\n  }\n}\n","// Libraries\nimport { chain, difference } from 'lodash';\nimport LRU from 'lru-cache';\n\n// Services & Utils\nimport {\n  parseSelector,\n  labelRegexp,\n  selectorRegexp,\n  processLabels,\n} from 'app/plugins/datasource/prometheus/language_utils';\nimport syntax, { FUNCTIONS, PIPE_PARSERS, PIPE_OPERATORS } from './syntax';\n\n// Types\nimport { LokiQuery } from './types';\nimport { dateTime, AbsoluteTimeRange, LanguageProvider, HistoryItem, DataQuery, DataSourceApi } from '@grafana/data';\nimport { PromQuery } from '../prometheus/types';\nimport { GraphiteQuery } from '../graphite/types';\n\nimport LokiDatasource from './datasource';\nimport { CompletionItem, TypeaheadInput, TypeaheadOutput, CompletionItemGroup } from '@grafana/ui';\nimport { Grammar } from 'prismjs';\nimport fromGraphite from './importing/fromGraphite';\nimport { GraphiteDatasource } from '../graphite/datasource';\n\nconst DEFAULT_KEYS = ['job', 'namespace'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 10;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\nconst NS_IN_MS = 1000000;\n\n// When changing RATE_RANGES, check if Prometheus/PromQL ranges should be changed too\n// @see public/app/plugins/datasource/prometheus/promql.ts\nconst RATE_RANGES: CompletionItem[] = [\n  { label: '$__interval', sortValue: '$__interval' },\n  { label: '$__range', sortValue: '$__range' },\n  { label: '1m', sortValue: '00:01:00' },\n  { label: '5m', sortValue: '00:05:00' },\n  { label: '10m', sortValue: '00:10:00' },\n  { label: '30m', sortValue: '00:30:00' },\n  { label: '1h', sortValue: '01:00:00' },\n  { label: '1d', sortValue: '24:00:00' },\n];\n\nexport const LABEL_REFRESH_INTERVAL = 1000 * 30; // 30sec\n\nconst wrapLabel = (label: string) => ({ label, filterText: `\\\"${label}\\\"` });\n\nexport type LokiHistoryItem = HistoryItem<LokiQuery>;\n\ntype TypeaheadContext = {\n  history?: LokiHistoryItem[];\n  absoluteRange?: AbsoluteTimeRange;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: LokiHistoryItem[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter((h) => h.ts > cutoffTs && h.query.expr === item.label);\n  let hint = `Queried ${historyForItem.length} times in the last 24h.`;\n  const recent = historyForItem[0];\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nexport default class LokiLanguageProvider extends LanguageProvider {\n  labelKeys: string[];\n  labelFetchTs: number;\n  started = false;\n  datasource: LokiDatasource;\n  lookupsDisabled = false; // Dynamically set to true for big/slow instances\n\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  private seriesCache = new LRU<string, Record<string, string[]>>(10);\n  private labelsCache = new LRU<string, string[]>(10);\n\n  constructor(datasource: LokiDatasource, initialValues?: any) {\n    super();\n\n    this.datasource = datasource;\n    this.labelKeys = [];\n    this.labelFetchTs = 0;\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars\n  cleanText = (s: string) => s.replace(/[{}[\\]=\"(),!~+\\-*/^%\\|]/g, '').trim();\n\n  getSyntax(): Grammar {\n    return syntax;\n  }\n\n  request = async (url: string, params?: any): Promise<any> => {\n    try {\n      return await this.datasource.metadataRequest(url, params);\n    } catch (error) {\n      console.error(error);\n    }\n\n    return undefined;\n  };\n\n  /**\n   * Initialise the language provider by fetching set of labels. Without this initialisation the provider would return\n   * just a set of hardcoded default labels on provideCompletionItems or a recent queries from history.\n   */\n  start = () => {\n    if (!this.startTask) {\n      this.startTask = this.fetchLabels().then(() => {\n        this.started = true;\n        return [];\n      });\n    }\n\n    return this.startTask;\n  };\n\n  getLabelKeys(): string[] {\n    return this.labelKeys;\n  }\n\n  /**\n   * Return suggestions based on input that can be then plugged into a typeahead dropdown.\n   * Keep this DOM-free for testing\n   * @param input\n   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems\n   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems\n   * @param context.history Optional used only in getEmptyCompletionItems\n   */\n  async provideCompletionItems(input: TypeaheadInput, context?: TypeaheadContext): Promise<TypeaheadOutput> {\n    const { wrapperClasses, value, prefix, text } = input;\n    const emptyResult: TypeaheadOutput = { suggestions: [] };\n\n    if (!value) {\n      return emptyResult;\n    }\n\n    // Local text properties\n    const empty = value?.document.text.length === 0;\n    const selectedLines = value.document.getTextsAtRange(value.selection);\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null;\n\n    // Syntax spans have 3 classes by default. More indicate a recognized token\n    const tokenRecognized = wrapperClasses.length > 3;\n\n    // Non-empty prefix, but not inside known token\n    const prefixUnrecognized = prefix && !tokenRecognized;\n\n    // Prevent suggestions in `function(|suffix)`\n    const noSuffix = !nextCharacter || nextCharacter === ')';\n\n    // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n    const safePrefix = prefix && !text.match(/^['\"~=\\]})\\s]+$/) && noSuffix;\n\n    // About to type next operand if preceded by binary operator\n    const operatorsPattern = /[+\\-*/^%]/;\n    const isNextOperand = text.match(operatorsPattern);\n\n    // Determine candidates by CSS context\n    if (wrapperClasses.includes('context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeCompletionItems();\n    } else if (wrapperClasses.includes('context-labels')) {\n      // Suggestions for {|} and {foo=|}\n      return await this.getLabelCompletionItems(input);\n    } else if (wrapperClasses.includes('context-pipe')) {\n      return this.getPipeCompletionItem();\n    } else if (empty) {\n      // Suggestions for empty query field\n      return this.getEmptyCompletionItems(context);\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n      // Show term suggestions in a couple of scenarios\n      return this.getBeginningCompletionItems(context);\n    } else if (prefixUnrecognized && safePrefix) {\n      // Show term suggestions in a couple of scenarios\n      return this.getTermCompletionItems();\n    }\n\n    return emptyResult;\n  }\n\n  getBeginningCompletionItems = (context?: TypeaheadContext): TypeaheadOutput => {\n    return {\n      suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions],\n    };\n  };\n\n  getEmptyCompletionItems(context?: TypeaheadContext): TypeaheadOutput {\n    const history = context?.history;\n    const suggestions = [];\n\n    if (history?.length) {\n      const historyItems = chain(history)\n        .map((h) => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map((item) => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  }\n\n  getTermCompletionItems = (): TypeaheadOutput => {\n    const suggestions = [];\n\n    suggestions.push({\n      prefixMatch: true,\n      label: 'Functions',\n      items: FUNCTIONS.map((suggestion) => ({ ...suggestion, kind: 'function' })),\n    });\n\n    return { suggestions };\n  };\n\n  getPipeCompletionItem = (): TypeaheadOutput => {\n    const suggestions = [];\n\n    suggestions.push({\n      label: 'Operators',\n      items: PIPE_OPERATORS.map((suggestion) => ({ ...suggestion, kind: 'operators' })),\n    });\n\n    suggestions.push({\n      label: 'Parsers',\n      items: PIPE_PARSERS.map((suggestion) => ({ ...suggestion, kind: 'parsers' })),\n    });\n\n    return { suggestions };\n  };\n\n  getRangeCompletionItems(): TypeaheadOutput {\n    return {\n      context: 'context-range',\n      suggestions: [\n        {\n          label: 'Range vector',\n          items: [...RATE_RANGES],\n        },\n      ],\n    };\n  }\n\n  async getLabelCompletionItems({ text, wrapperClasses, labelKey, value }: TypeaheadInput): Promise<TypeaheadOutput> {\n    let context = 'context-labels';\n    const suggestions: CompletionItemGroup[] = [];\n    if (!value) {\n      return { context, suggestions: [] };\n    }\n    const line = value.anchorBlock.getText();\n    const cursorOffset = value.selection.anchor.offset;\n    const isValueStart = text.match(/^(=|=~|!=|!~)/);\n\n    // Get normalized selector\n    let selector;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n      selector = parsedSelector.selector;\n    } catch {\n      selector = EMPTY_SELECTOR;\n    }\n\n    if (!labelKey && selector === EMPTY_SELECTOR) {\n      // start task gets all labels\n      await this.start();\n      const allLabels = this.getLabelKeys();\n      return { context, suggestions: [{ label: `Labels`, items: allLabels.map(wrapLabel) }] };\n    }\n\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    let labelValues;\n    // Query labels for selector\n    if (selector) {\n      if (selector === EMPTY_SELECTOR && labelKey) {\n        const labelValuesForKey = await this.getLabelValues(labelKey);\n        labelValues = { [labelKey]: labelValuesForKey };\n      } else {\n        labelValues = await this.getSeriesLabels(selector);\n      }\n    }\n\n    if (!labelValues) {\n      console.warn(`Server did not return any values for selector = ${selector}`);\n      return { context, suggestions };\n    }\n\n    if ((text && isValueStart) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && labelValues[labelKey]) {\n        context = 'context-label-values';\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"`,\n          // Filter to prevent previously selected values from being repeatedly suggested\n          items: labelValues[labelKey].map(wrapLabel).filter(({ filterText }) => filterText !== text),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = labelValues ? Object.keys(labelValues) : DEFAULT_KEYS;\n      if (labelKeys) {\n        const possibleKeys = difference(labelKeys, existingKeys);\n        if (possibleKeys.length) {\n          const newItems = possibleKeys.map((key) => ({ label: key }));\n          const newSuggestion: CompletionItemGroup = { label: `Labels`, items: newItems };\n          suggestions.push(newSuggestion);\n        }\n      }\n    }\n\n    return { context, suggestions };\n  }\n\n  async importQueries(\n    queries: PromQuery[] | GraphiteQuery[] | DataQuery[],\n    originDataSource: DataSourceApi\n  ): Promise<LokiQuery[]> {\n    const datasourceType = originDataSource.meta.id;\n    if (datasourceType === 'prometheus') {\n      return Promise.all(\n        [...(queries as PromQuery[])].map(async (query) => {\n          const expr = await this.importPrometheusQuery(query.expr);\n          const { refId } = query;\n          return {\n            expr,\n            refId,\n            range: true,\n          };\n        })\n      );\n    }\n    if (datasourceType === 'graphite') {\n      return fromGraphite(queries, originDataSource as GraphiteDatasource);\n    }\n    // Return a cleaned LokiQuery\n    return queries.map((query) => ({\n      refId: query.refId,\n      expr: '',\n    }));\n  }\n\n  async importPrometheusQuery(query: string): Promise<string> {\n    if (!query) {\n      return '';\n    }\n\n    // Consider only first selector in query\n    const selectorMatch = query.match(selectorRegexp);\n    if (!selectorMatch) {\n      return '';\n    }\n\n    const selector = selectorMatch[0];\n    const labels: { [key: string]: { value: any; operator: any } } = {};\n    selector.replace(labelRegexp, (_, key, operator, value) => {\n      labels[key] = { value, operator };\n      return '';\n    });\n\n    // Keep only labels that exist on origin and target datasource\n    await this.start(); // fetches all existing label keys\n    const existingKeys = this.labelKeys;\n    let labelsToKeep: { [key: string]: { value: any; operator: any } } = {};\n    if (existingKeys && existingKeys.length) {\n      // Check for common labels\n      for (const key in labels) {\n        if (existingKeys && existingKeys.includes(key)) {\n          // Should we check for label value equality here?\n          labelsToKeep[key] = labels[key];\n        }\n      }\n    } else {\n      // Keep all labels by default\n      labelsToKeep = labels;\n    }\n\n    const labelKeys = Object.keys(labelsToKeep).sort();\n    const cleanSelector = labelKeys\n      .map((key) => `${key}${labelsToKeep[key].operator}${labelsToKeep[key].value}`)\n      .join(',');\n\n    return ['{', cleanSelector, '}'].join('');\n  }\n\n  async getSeriesLabels(selector: string) {\n    if (this.lookupsDisabled) {\n      return undefined;\n    }\n    try {\n      return await this.fetchSeriesLabels(selector);\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Fetches all label keys\n   */\n  async fetchLabels(): Promise<string[]> {\n    const url = '/loki/api/v1/label';\n    const timeRange = this.datasource.getTimeRangeParams();\n    this.labelFetchTs = Date.now().valueOf();\n\n    const res = await this.request(url, timeRange);\n    if (Array.isArray(res)) {\n      const labels = res\n        .slice()\n        .sort()\n        .filter((label) => label !== '__name__');\n      this.labelKeys = labels;\n    }\n\n    return [];\n  }\n\n  async refreshLogLabels(forceRefresh?: boolean) {\n    if ((this.labelKeys && Date.now().valueOf() - this.labelFetchTs > LABEL_REFRESH_INTERVAL) || forceRefresh) {\n      await this.fetchLabels();\n    }\n  }\n\n  /**\n   * Fetch labels for a selector. This is cached by it's args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   */\n  fetchSeriesLabels = async (match: string): Promise<Record<string, string[]>> => {\n    const url = '/loki/api/v1/series';\n    const { start, end } = this.datasource.getTimeRangeParams();\n\n    const cacheKey = this.generateCacheKey(url, start, end, match);\n    let value = this.seriesCache.get(cacheKey);\n    if (!value) {\n      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n      this.seriesCache.set(cacheKey, {});\n      const params = { 'match[]': match, start, end };\n      const data = await this.request(url, params);\n      const { values } = processLabels(data);\n      value = values;\n      this.seriesCache.set(cacheKey, value);\n    }\n    return value;\n  };\n\n  /**\n   * Fetch series for a selector. Use this for raw results. Use fetchSeriesLabels() to get labels.\n   * @param match\n   */\n  fetchSeries = async (match: string): Promise<Array<Record<string, string>>> => {\n    const url = '/loki/api/v1/series';\n    const { start, end } = this.datasource.getTimeRangeParams();\n    const params = { 'match[]': match, start, end };\n    return await this.request(url, params);\n  };\n\n  // Cache key is a bit different here. We round up to a minute the intervals.\n  // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n  // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n  // when user does not the newest values for a minute if already cached.\n  generateCacheKey(url: string, start: number, end: number, param: string): string {\n    return [url, this.roundTime(start), this.roundTime(end), param].join();\n  }\n\n  // Round nanos epoch to nearest 5 minute interval\n  roundTime(nanos: number): number {\n    return nanos ? Math.floor(nanos / NS_IN_MS / 1000 / 60 / 5) : 0;\n  }\n\n  async getLabelValues(key: string): Promise<string[]> {\n    return await this.fetchLabelValues(key);\n  }\n\n  async fetchLabelValues(key: string): Promise<string[]> {\n    const url = `/loki/api/v1/label/${key}/values`;\n    const rangeParams = this.datasource.getTimeRangeParams();\n    const { start, end } = rangeParams;\n\n    const cacheKey = this.generateCacheKey(url, start, end, key);\n    const params = { start, end };\n\n    let labelValues = this.labelsCache.get(cacheKey);\n    if (!labelValues) {\n      // Clear value when requesting new one. Empty object being truthy also makes sure we don't request twice.\n      this.labelsCache.set(cacheKey, []);\n      const res = await this.request(url, params);\n      if (Array.isArray(res)) {\n        labelValues = res.slice().sort();\n        this.labelsCache.set(cacheKey, labelValues);\n      }\n    }\n\n    return labelValues ?? [];\n  }\n}\n","// Libraries\nimport { cloneDeep, isEmpty, map as lodashMap } from 'lodash';\nimport { lastValueFrom, merge, Observable, of, throwError } from 'rxjs';\nimport { catchError, map, switchMap } from 'rxjs/operators';\nimport Prism from 'prismjs';\n\n// Types\nimport {\n  AnnotationEvent,\n  AnnotationQueryRequest,\n  DataFrame,\n  DataFrameView,\n  DataQuery,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataSourceWithLogsContextSupport,\n  DataSourceWithLogsVolumeSupport,\n  dateMath,\n  DateTime,\n  FieldCache,\n  FieldType,\n  getLogLevelFromKey,\n  Labels,\n  LoadingState,\n  LogLevel,\n  LogRowModel,\n  QueryResultMeta,\n  ScopedVars,\n  TimeRange,\n} from '@grafana/data';\nimport { BackendSrvRequest, FetchError, getBackendSrv } from '@grafana/runtime';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\nimport { addLabelToQuery } from 'app/plugins/datasource/prometheus/add_label_to_query';\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { convertToWebSocketUrl } from 'app/core/utils/explore';\nimport {\n  lokiResultsToTableModel,\n  lokiStreamResultToDataFrame,\n  lokiStreamsToDataFrames,\n  processRangeQueryResponse,\n} from './result_transformer';\nimport { addParsedLabelToQuery, queryHasPipeParser } from './query_utils';\n\nimport {\n  LokiOptions,\n  LokiQuery,\n  LokiRangeQueryRequest,\n  LokiResultType,\n  LokiStreamResponse,\n  LokiStreamResult,\n} from './types';\nimport { LiveStreams, LokiLiveTarget } from './live_streams';\nimport LanguageProvider from './language_provider';\nimport { serializeParams } from '../../../core/utils/fetch';\nimport { RowContextOptions } from '@grafana/ui/src/components/Logs/LogRowContextProvider';\nimport syntax from './syntax';\nimport { DEFAULT_RESOLUTION } from './components/LokiOptionFields';\nimport { queryLogsVolume } from 'app/core/logs_model';\nimport config from 'app/core/config';\n\nexport type RangeQueryOptions = DataQueryRequest<LokiQuery> | AnnotationQueryRequest<LokiQuery>;\nexport const DEFAULT_MAX_LINES = 1000;\nexport const LOKI_ENDPOINT = '/loki/api/v1';\nconst NS_IN_MS = 1000000;\n\n/**\n * Loki's logs volume query may be expensive as it requires counting all logs in the selected range. If such query\n * takes too much time it may need be made more specific to limit number of logs processed under the hood.\n */\nconst LOGS_VOLUME_TIMEOUT = 10000;\n\nconst RANGE_QUERY_ENDPOINT = `${LOKI_ENDPOINT}/query_range`;\nconst INSTANT_QUERY_ENDPOINT = `${LOKI_ENDPOINT}/query`;\n\nconst DEFAULT_QUERY_PARAMS: Partial<LokiRangeQueryRequest> = {\n  direction: 'BACKWARD',\n  limit: DEFAULT_MAX_LINES,\n  query: '',\n};\n\nexport class LokiDatasource\n  extends DataSourceApi<LokiQuery, LokiOptions>\n  implements DataSourceWithLogsContextSupport, DataSourceWithLogsVolumeSupport<LokiQuery> {\n  private streams = new LiveStreams();\n  languageProvider: LanguageProvider;\n  maxLines: number;\n\n  constructor(\n    private instanceSettings: DataSourceInstanceSettings<LokiOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv(),\n    private readonly timeSrv: TimeSrv = getTimeSrv()\n  ) {\n    super(instanceSettings);\n\n    this.languageProvider = new LanguageProvider(this);\n    const settingsData = instanceSettings.jsonData || {};\n    this.maxLines = parseInt(settingsData.maxLines ?? '0', 10) || DEFAULT_MAX_LINES;\n  }\n\n  _request(apiUrl: string, data?: any, options?: Partial<BackendSrvRequest>): Observable<Record<string, any>> {\n    const baseUrl = this.instanceSettings.url;\n    const params = data ? serializeParams(data) : '';\n    const url = `${baseUrl}${apiUrl}${params.length ? `?${params}` : ''}`;\n    if (this.instanceSettings.withCredentials || this.instanceSettings.basicAuth) {\n      options = { ...options, withCredentials: true };\n      if (this.instanceSettings.basicAuth) {\n        options.headers = { ...options.headers, Authorization: this.instanceSettings.basicAuth };\n      }\n    }\n    const req = {\n      ...options,\n      url,\n    };\n\n    return getBackendSrv().fetch<Record<string, any>>(req);\n  }\n\n  getLogsVolumeDataProvider(request: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> | undefined {\n    if (!config.featureToggles.fullRangeLogsVolume) {\n      return undefined;\n    }\n\n    const isLogsVolumeAvailable = request.targets.some((target) => target.expr && !isMetricsQuery(target.expr));\n    if (!isLogsVolumeAvailable) {\n      return undefined;\n    }\n\n    const logsVolumeRequest = cloneDeep(request);\n    logsVolumeRequest.targets = logsVolumeRequest.targets\n      .filter((target) => target.expr && !isMetricsQuery(target.expr))\n      .map((target) => {\n        return {\n          ...target,\n          instant: false,\n          volumeQuery: true,\n          expr: `sum by (level) (count_over_time(${target.expr}[$__interval]))`,\n        };\n      });\n\n    return queryLogsVolume(this, logsVolumeRequest, {\n      timeout: LOGS_VOLUME_TIMEOUT,\n      extractLevel,\n      range: request.range,\n      targets: request.targets,\n    });\n  }\n\n  query(options: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> {\n    const subQueries: Array<Observable<DataQueryResponse>> = [];\n    const scopedVars = {\n      ...options.scopedVars,\n      ...this.getRangeScopedVars(options.range),\n    };\n    const filteredTargets = options.targets\n      .filter((target) => target.expr && !target.hide)\n      .map((target) => {\n        const expr = this.addAdHocFilters(target.expr);\n        return {\n          ...target,\n          expr: this.templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr),\n        };\n      });\n\n    for (const target of filteredTargets) {\n      if (target.instant) {\n        subQueries.push(this.runInstantQuery(target, options, filteredTargets.length));\n      } else {\n        subQueries.push(this.runRangeQuery(target, options, filteredTargets.length));\n      }\n    }\n\n    // No valid targets, return the empty result to save a round trip.\n    if (isEmpty(subQueries)) {\n      return of({\n        data: [],\n        state: LoadingState.Done,\n      });\n    }\n\n    return merge(...subQueries);\n  }\n\n  runInstantQuery = (\n    target: LokiQuery,\n    options: DataQueryRequest<LokiQuery>,\n    responseListLength = 1\n  ): Observable<DataQueryResponse> => {\n    const timeNs = this.getTime(options.range.to, true);\n    const queryLimit = isMetricsQuery(target.expr) ? options.maxDataPoints : target.maxLines;\n    const query = {\n      query: target.expr,\n      time: `${timeNs + (1e9 - (timeNs % 1e9))}`,\n      limit: Math.min(queryLimit || Infinity, this.maxLines),\n    };\n\n    /** Used only for results of metrics instant queries */\n    const meta: QueryResultMeta = {\n      preferredVisualisationType: 'table',\n    };\n\n    return this._request(INSTANT_QUERY_ENDPOINT, query).pipe(\n      map((response) => {\n        if (response.data.data.resultType === LokiResultType.Stream) {\n          return {\n            data: response.data\n              ? lokiStreamsToDataFrames(\n                  response.data as LokiStreamResponse,\n                  target,\n                  query.limit,\n                  this.instanceSettings.jsonData\n                )\n              : [],\n            key: `${target.refId}_instant`,\n          };\n        }\n\n        return {\n          data: [lokiResultsToTableModel(response.data.data.result, responseListLength, target.refId, meta, true)],\n          key: `${target.refId}_instant`,\n        };\n      }),\n      catchError((err) => throwError(() => this.processError(err, target)))\n    );\n  };\n\n  createRangeQuery(target: LokiQuery, options: RangeQueryOptions, limit: number): LokiRangeQueryRequest {\n    const query = target.expr;\n    let range: { start?: number; end?: number; step?: number } = {};\n    if (options.range) {\n      const startNs = this.getTime(options.range.from, false);\n      const endNs = this.getTime(options.range.to, true);\n      const rangeMs = Math.ceil((endNs - startNs) / 1e6);\n\n      const resolution = target.resolution || (DEFAULT_RESOLUTION.value as number);\n\n      const adjustedInterval =\n        this.adjustInterval((options as DataQueryRequest<LokiQuery>).intervalMs || 1000, resolution, rangeMs) / 1000;\n      // We want to ceil to 3 decimal places\n      const step = Math.ceil(adjustedInterval * 1000) / 1000;\n\n      range = {\n        start: startNs,\n        end: endNs,\n        step,\n      };\n    }\n\n    return {\n      ...DEFAULT_QUERY_PARAMS,\n      ...range,\n      query,\n      limit,\n    };\n  }\n\n  /**\n   * Attempts to send a query to /loki/api/v1/query_range\n   */\n  runRangeQuery = (\n    target: LokiQuery,\n    options: RangeQueryOptions,\n    responseListLength = 1\n  ): Observable<DataQueryResponse> => {\n    // For metric query we use maxDataPoints from the request options which should be something like width of the\n    // visualisation in pixels. In case of logs request we either use lines limit defined in the query target or\n    // global limit defined for the data source which ever is lower.\n    let maxDataPoints = isMetricsQuery(target.expr)\n      ? // We fallback to maxLines here because maxDataPoints is defined as possibly undefined. Not sure that can\n        // actually happen both Dashboards and Explore should send some value here. If not maxLines does not make that\n        // much sense but nor any other arbitrary value.\n        (options as DataQueryRequest<LokiQuery>).maxDataPoints || this.maxLines\n      : // If user wants maxLines 0 we still fallback to data source limit. I think that makes sense as why would anyone\n        // want to do a query and not see any results?\n        target.maxLines || this.maxLines;\n\n    if ((options as DataQueryRequest<LokiQuery>).liveStreaming) {\n      return this.runLiveQuery(target, maxDataPoints);\n    }\n    const query = this.createRangeQuery(target, options, maxDataPoints);\n\n    const headers = target.volumeQuery ? { 'X-Query-Tags': 'Source=logvolhist' } : undefined;\n\n    return this._request(RANGE_QUERY_ENDPOINT, query, { headers }).pipe(\n      catchError((err) => throwError(() => this.processError(err, target))),\n      switchMap((response) =>\n        processRangeQueryResponse(\n          response.data,\n          target,\n          query,\n          responseListLength,\n          maxDataPoints,\n          this.instanceSettings.jsonData,\n          (options as DataQueryRequest<LokiQuery>).scopedVars,\n          (options as DataQueryRequest<LokiQuery>).reverse\n        )\n      )\n    );\n  };\n\n  createLiveTarget(target: LokiQuery, maxDataPoints: number): LokiLiveTarget {\n    const query = target.expr;\n    const baseUrl = this.instanceSettings.url;\n    const params = serializeParams({ query });\n\n    return {\n      query,\n      url: convertToWebSocketUrl(`${baseUrl}/loki/api/v1/tail?${params}`),\n      refId: target.refId,\n      size: maxDataPoints,\n    };\n  }\n\n  /**\n   * Runs live queries which in this case means creating a websocket and listening on it for new logs.\n   * This returns a bit different dataFrame than runQueries as it returns single dataframe even if there are multiple\n   * Loki streams, sets only common labels on dataframe.labels and has additional dataframe.fields.labels for unique\n   * labels per row.\n   */\n  runLiveQuery = (target: LokiQuery, maxDataPoints: number): Observable<DataQueryResponse> => {\n    const liveTarget = this.createLiveTarget(target, maxDataPoints);\n\n    return this.streams.getStream(liveTarget).pipe(\n      map((data) => ({\n        data: data || [],\n        key: `loki-${liveTarget.refId}`,\n        state: LoadingState.Streaming,\n      })),\n      catchError((err: any) => {\n        return throwError(() => `Live tailing was stopped due to following error: ${err.reason}`);\n      })\n    );\n  };\n\n  getRangeScopedVars(range: TimeRange = this.timeSrv.timeRange()) {\n    const msRange = range.to.diff(range.from);\n    const sRange = Math.round(msRange / 1000);\n    return {\n      __range_ms: { text: msRange, value: msRange },\n      __range_s: { text: sRange, value: sRange },\n      __range: { text: sRange + 's', value: sRange + 's' },\n    };\n  }\n\n  interpolateVariablesInQueries(queries: LokiQuery[], scopedVars: ScopedVars): LokiQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length) {\n      expandedQueries = queries.map((query) => ({\n        ...query,\n        datasource: this.getRef(),\n        expr: this.templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),\n      }));\n    }\n\n    return expandedQueries;\n  }\n\n  getQueryDisplayText(query: LokiQuery) {\n    return query.expr;\n  }\n\n  getTimeRangeParams() {\n    const timeRange = this.timeSrv.timeRange();\n    return { start: timeRange.from.valueOf() * NS_IN_MS, end: timeRange.to.valueOf() * NS_IN_MS };\n  }\n\n  async importQueries(queries: DataQuery[], originDataSource: DataSourceApi): Promise<LokiQuery[]> {\n    return this.languageProvider.importQueries(queries, originDataSource);\n  }\n\n  async metadataRequest(url: string, params?: Record<string, string | number>) {\n    const res = await lastValueFrom(this._request(url, params, { hideFromInspector: true }));\n    return res.data.data || res.data.values || [];\n  }\n\n  async metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    const interpolated = this.templateSrv.replace(query, {}, this.interpolateQueryExpr);\n    return await this.processMetricFindQuery(interpolated);\n  }\n\n  async processMetricFindQuery(query: string) {\n    const labelNamesRegex = /^label_names\\(\\)\\s*$/;\n    const labelValuesRegex = /^label_values\\((?:(.+),\\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*$/;\n\n    const labelNames = query.match(labelNamesRegex);\n    if (labelNames) {\n      return await this.labelNamesQuery();\n    }\n\n    const labelValues = query.match(labelValuesRegex);\n    if (labelValues) {\n      // If we have query expr, use /series endpoint\n      if (labelValues[1]) {\n        return await this.labelValuesSeriesQuery(labelValues[1], labelValues[2]);\n      }\n      return await this.labelValuesQuery(labelValues[2]);\n    }\n\n    return Promise.resolve([]);\n  }\n\n  async labelNamesQuery() {\n    const url = `${LOKI_ENDPOINT}/label`;\n    const params = this.getTimeRangeParams();\n    const result = await this.metadataRequest(url, params);\n    return result.map((value: string) => ({ text: value }));\n  }\n\n  async labelValuesQuery(label: string) {\n    const params = this.getTimeRangeParams();\n    const url = `${LOKI_ENDPOINT}/label/${label}/values`;\n    const result = await this.metadataRequest(url, params);\n    return result.map((value: string) => ({ text: value }));\n  }\n\n  async labelValuesSeriesQuery(expr: string, label: string) {\n    const timeParams = this.getTimeRangeParams();\n    const params = {\n      ...timeParams,\n      'match[]': expr,\n    };\n    const url = `${LOKI_ENDPOINT}/series`;\n    const streams = new Set();\n    const result = await this.metadataRequest(url, params);\n    result.forEach((stream: { [key: string]: string }) => {\n      if (stream[label]) {\n        streams.add({ text: stream[label] });\n      }\n    });\n\n    return Array.from(streams);\n  }\n\n  // By implementing getTagKeys and getTagValues we add ad-hoc filtters functionality\n  async getTagKeys() {\n    return await this.labelNamesQuery();\n  }\n\n  async getTagValues(options: any = {}) {\n    return await this.labelValuesQuery(options.key);\n  }\n\n  interpolateQueryExpr(value: any, variable: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return lokiRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return lokiSpecialRegexEscape(value);\n    }\n\n    const escapedValues = lodashMap(value, lokiSpecialRegexEscape);\n    return escapedValues.join('|');\n  }\n\n  modifyQuery(query: LokiQuery, action: any): LokiQuery {\n    let expression = query.expr ?? '';\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        expression = this.addLabelToQuery(expression, action.key, action.value, '=');\n        break;\n      }\n      case 'ADD_FILTER_OUT': {\n        expression = this.addLabelToQuery(expression, action.key, action.value, '!=');\n        break;\n      }\n      default:\n        break;\n    }\n    return { ...query, expr: expression };\n  }\n\n  getTime(date: string | DateTime, roundUp: boolean) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp)!;\n    }\n\n    return Math.ceil(date.valueOf() * 1e6);\n  }\n\n  getLogRowContext = (row: LogRowModel, options?: RowContextOptions): Promise<{ data: DataFrame[] }> => {\n    const target = this.prepareLogRowContextQueryTarget(\n      row,\n      (options && options.limit) || 10,\n      (options && options.direction) || 'BACKWARD'\n    );\n\n    const reverse = options && options.direction === 'FORWARD';\n    return lastValueFrom(\n      this._request(RANGE_QUERY_ENDPOINT, target).pipe(\n        catchError((err) => {\n          const error: DataQueryError = {\n            message: 'Error during context query. Please check JS console logs.',\n            status: err.status,\n            statusText: err.statusText,\n          };\n          throw error;\n        }),\n        switchMap((res) =>\n          of({\n            data: res.data\n              ? res.data.data.result.map((stream: LokiStreamResult) => lokiStreamResultToDataFrame(stream, reverse))\n              : [],\n          })\n        )\n      )\n    );\n  };\n\n  prepareLogRowContextQueryTarget = (row: LogRowModel, limit: number, direction: 'BACKWARD' | 'FORWARD') => {\n    const labels = this.languageProvider.getLabelKeys();\n    const query = Object.keys(row.labels)\n      .map((label: string) => {\n        if (labels.includes(label)) {\n          // escape backslashes in label as users can't escape them by themselves\n          return `${label}=\"${row.labels[label].replace(/\\\\/g, '\\\\\\\\')}\"`;\n        }\n        return '';\n      })\n      // Filter empty strings\n      .filter((label) => !!label)\n      .join(',');\n\n    const contextTimeBuffer = 2 * 60 * 60 * 1000; // 2h buffer\n    const commonTargetOptions = {\n      limit,\n      query: `{${query}}`,\n      expr: `{${query}}`,\n      direction,\n    };\n\n    const fieldCache = new FieldCache(row.dataFrame);\n    const nsField = fieldCache.getFieldByName('tsNs')!;\n    const nsTimestamp = nsField.values.get(row.rowIndex);\n\n    if (direction === 'BACKWARD') {\n      return {\n        ...commonTargetOptions,\n        // convert to ns, we loose some precision here but it is not that important at the far points of the context\n        start: row.timeEpochMs - contextTimeBuffer + '000000',\n        end: nsTimestamp,\n        direction,\n      };\n    } else {\n      return {\n        ...commonTargetOptions,\n        // start param in Loki API is inclusive so we'll have to filter out the row that this request is based from\n        // and any other that were logged in the same ns but before the row. Right now these rows will be lost\n        // because the are before but came it he response that should return only rows after.\n        start: nsTimestamp,\n        // convert to ns, we loose some precision here but it is not that important at the far points of the context\n        end: row.timeEpochMs + contextTimeBuffer + '000000',\n      };\n    }\n  };\n\n  testDatasource() {\n    // Consider only last 10 minutes otherwise request takes too long\n    const startMs = Date.now() - 10 * 60 * 1000;\n    const start = `${startMs}000000`; // API expects nanoseconds\n    return lastValueFrom(\n      this._request(`${LOKI_ENDPOINT}/label`, { start }).pipe(\n        map((res) => {\n          const values: any[] = res?.data?.data || res?.data?.values || [];\n          const testResult =\n            values.length > 0\n              ? { status: 'success', message: 'Data source connected and labels found.' }\n              : {\n                  status: 'error',\n                  message:\n                    'Data source connected, but no labels received. Verify that Loki and Promtail is configured properly.',\n                };\n          return testResult;\n        }),\n        catchError((err: any) => {\n          let message = 'Loki: ';\n          if (err.statusText) {\n            message += err.statusText;\n          } else {\n            message += 'Cannot connect to Loki';\n          }\n\n          if (err.status) {\n            message += `. ${err.status}`;\n          }\n\n          if (err.data && err.data.message) {\n            message += `. ${err.data.message}`;\n          } else if (err.data) {\n            message += `. ${err.data}`;\n          }\n          return of({ status: 'error', message: message });\n        })\n      )\n    );\n  }\n\n  async annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const {\n      expr,\n      maxLines,\n      instant,\n      stepInterval,\n      tagKeys = '',\n      titleFormat = '',\n      textFormat = '',\n    } = options.annotation;\n\n    if (!expr) {\n      return [];\n    }\n\n    const interpolatedExpr = this.templateSrv.replace(expr, {}, this.interpolateQueryExpr);\n    const query = {\n      refId: `annotation-${options.annotation.name}`,\n      expr: interpolatedExpr,\n      maxLines,\n      instant,\n      stepInterval,\n    };\n    const { data } = instant\n      ? await lastValueFrom(this.runInstantQuery(query, options as any))\n      : await lastValueFrom(this.runRangeQuery(query, options as any));\n\n    const annotations: AnnotationEvent[] = [];\n    const splitKeys: string[] = tagKeys.split(',').filter((v: string) => v !== '');\n\n    for (const frame of data) {\n      const labels: { [key: string]: string } = {};\n      for (const field of frame.fields) {\n        if (field.labels) {\n          for (const [key, value] of Object.entries(field.labels)) {\n            labels[key] = String(value).trim();\n          }\n        }\n      }\n\n      const tags: string[] = [\n        ...new Set(\n          Object.entries(labels).reduce((acc: string[], [key, val]) => {\n            if (val === '') {\n              return acc;\n            }\n            if (splitKeys.length && !splitKeys.includes(key)) {\n              return acc;\n            }\n            acc.push.apply(acc, [val]);\n            return acc;\n          }, [])\n        ),\n      ];\n\n      const view = new DataFrameView<{ ts: string; line: string }>(frame);\n\n      view.forEach((row) => {\n        annotations.push({\n          time: new Date(row.ts).valueOf(),\n          title: renderTemplate(titleFormat, labels),\n          text: renderTemplate(textFormat, labels) || row.line,\n          tags,\n        });\n      });\n    }\n\n    return annotations;\n  }\n\n  showContextToggle(row?: LogRowModel): boolean {\n    return (row && row.searchWords && row.searchWords.length > 0) === true;\n  }\n\n  processError(err: FetchError, target: LokiQuery) {\n    let error = cloneDeep(err);\n    if (err.data.message.includes('escape') && target.expr.includes('\\\\')) {\n      error.data.message = `Error: ${err.data.message}. Make sure that all special characters are escaped with \\\\. For more information on escaping of special characters visit LogQL documentation at https://grafana.com/docs/loki/latest/logql/.`;\n    }\n    return error;\n  }\n\n  adjustInterval(dynamicInterval: number, resolution: number, range: number) {\n    // Loki will drop queries that might return more than 11000 data points.\n    // Calibrate interval if it is too small.\n    let safeInterval = range / 11000;\n    if (safeInterval > 1) {\n      safeInterval = Math.ceil(safeInterval);\n    }\n\n    let adjustedInterval = Math.max(resolution * dynamicInterval, safeInterval);\n    return adjustedInterval;\n  }\n\n  addAdHocFilters(queryExpr: string) {\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    let expr = queryExpr;\n\n    expr = adhocFilters.reduce((acc: string, filter: { key?: any; operator?: any; value?: any }) => {\n      const { key, operator } = filter;\n      let { value } = filter;\n      if (operator === '=~' || operator === '!~') {\n        value = lokiRegularEscape(value);\n      }\n\n      return this.addLabelToQuery(acc, key, value, operator);\n    }, expr);\n\n    return expr;\n  }\n\n  addLabelToQuery(queryExpr: string, key: string, value: string | number, operator: string) {\n    if (queryHasPipeParser(queryExpr) && !isMetricsQuery(queryExpr)) {\n      // If query has parser, we treat all labels as parsed and use | key=\"value\" syntax\n      return addParsedLabelToQuery(queryExpr, key, value, operator);\n    } else {\n      return addLabelToQuery(queryExpr, key, value, operator, true);\n    }\n  }\n}\n\nexport function renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_match, g1) => {\n    if (aliasData[g1]) {\n      return aliasData[g1];\n    }\n    return '';\n  });\n}\n\nexport function lokiRegularEscape(value: any) {\n  if (typeof value === 'string') {\n    return value.replace(/'/g, \"\\\\\\\\'\");\n  }\n  return value;\n}\n\nexport function lokiSpecialRegexEscape(value: any) {\n  if (typeof value === 'string') {\n    return lokiRegularEscape(value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]+?.()|]/g, '\\\\\\\\$&'));\n  }\n  return value;\n}\n\n/**\n * Checks if the query expression uses function and so should return a time series instead of logs.\n * Sometimes important to know that before we actually do the query.\n */\nexport function isMetricsQuery(query: string): boolean {\n  const tokens = Prism.tokenize(query, syntax);\n  return tokens.some((t) => {\n    // Not sure in which cases it can be string maybe if nothing matched which means it should not be a function\n    return typeof t !== 'string' && t.type === 'function';\n  });\n}\n\nfunction extractLevel(dataFrame: DataFrame): LogLevel {\n  let valueField;\n  try {\n    valueField = new FieldCache(dataFrame).getFirstFieldOfType(FieldType.number);\n  } catch {}\n  return valueField?.labels ? getLogLevelFromLabels(valueField.labels) : LogLevel.unknown;\n}\n\nfunction getLogLevelFromLabels(labels: Labels): LogLevel {\n  const labelNames = ['level', 'lvl', 'loglevel'];\n  let levelLabel;\n  for (let labelName of labelNames) {\n    if (labelName in labels) {\n      levelLabel = labelName;\n      break;\n    }\n  }\n  return levelLabel ? getLogLevelFromKey(labels[levelLabel]) : LogLevel.unknown;\n}\n\nexport default LokiDatasource;\n","import React, { PureComponent } from 'react';\nimport { shuffle } from 'lodash';\nimport { QueryEditorHelpProps } from '@grafana/data';\nimport LokiLanguageProvider from '../language_provider';\nimport { LokiQuery } from '../types';\n\nconst DEFAULT_EXAMPLES = ['{job=\"default/prometheus\"}'];\nconst PREFERRED_LABELS = ['job', 'app', 'k8s_app'];\nconst EXAMPLES_LIMIT = 5;\n\nconst LOGQL_EXAMPLES = [\n  {\n    title: 'Log pipeline',\n    expression: '{job=\"mysql\"} |= \"metrics\" | logfmt | duration > 10s',\n    label:\n      'This query targets the MySQL job, filters out logs that don’t contain the word \"metrics\" and parses each log line to extract more labels and filters with them.',\n  },\n  {\n    title: 'Count over time',\n    expression: 'count_over_time({job=\"mysql\"}[5m])',\n    label: 'This query counts all the log lines within the last five minutes for the MySQL job.',\n  },\n  {\n    title: 'Rate',\n    expression: 'rate(({job=\"mysql\"} |= \"error\" != \"timeout\")[10s])',\n    label:\n      'This query gets the per-second rate of all non-timeout errors within the last ten seconds for the MySQL job.',\n  },\n  {\n    title: 'Aggregate, count, and group',\n    expression: 'sum(count_over_time({job=\"mysql\"}[5m])) by (level)',\n    label: 'Get the count of logs during the last five minutes, grouping by level.',\n  },\n];\n\nexport default class LokiCheatSheet extends PureComponent<QueryEditorHelpProps<LokiQuery>, { userExamples: string[] }> {\n  declare userLabelTimer: NodeJS.Timeout;\n  state = {\n    userExamples: [],\n  };\n\n  componentDidMount() {\n    this.scheduleUserLabelChecking();\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this.userLabelTimer);\n  }\n\n  scheduleUserLabelChecking() {\n    this.userLabelTimer = setTimeout(this.checkUserLabels, 1000);\n  }\n\n  checkUserLabels = async () => {\n    // Set example from user labels\n    const provider: LokiLanguageProvider = this.props.datasource?.languageProvider;\n    if (provider.started) {\n      const labels = provider.getLabelKeys() || [];\n      const preferredLabel = PREFERRED_LABELS.find((l) => labels.includes(l));\n      if (preferredLabel) {\n        const values = await provider.getLabelValues(preferredLabel);\n        const userExamples = shuffle(values)\n          .slice(0, EXAMPLES_LIMIT)\n          .map((value) => `{${preferredLabel}=\"${value}\"}`);\n        this.setState({ userExamples });\n      }\n    } else {\n      this.scheduleUserLabelChecking();\n    }\n  };\n\n  renderExpression(expr: string) {\n    const { onClickExample } = this.props;\n\n    return (\n      <div className=\"cheat-sheet-item__example\" key={expr} onClick={(e) => onClickExample({ refId: 'A', expr })}>\n        <code>{expr}</code>\n      </div>\n    );\n  }\n\n  render() {\n    const { userExamples } = this.state;\n    const hasUserExamples = userExamples.length > 0;\n\n    return (\n      <div>\n        <h2>Loki Cheat Sheet</h2>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">See your logs</div>\n          <div className=\"cheat-sheet-item__label\">\n            Start by selecting a log stream from the Log browser, or alternatively you can write a stream selector into\n            the query field.\n          </div>\n          {hasUserExamples ? (\n            <div>\n              <div className=\"cheat-sheet-item__label\">Here are some example streams from your logs:</div>\n              {userExamples.map((example) => this.renderExpression(example))}\n            </div>\n          ) : (\n            <div>\n              <div className=\"cheat-sheet-item__label\">Here is an example of a log stream:</div>\n              {this.renderExpression(DEFAULT_EXAMPLES[0])}\n            </div>\n          )}\n        </div>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Combine stream selectors</div>\n          {this.renderExpression('{app=\"cassandra\",namespace=\"prod\"}')}\n          <div className=\"cheat-sheet-item__label\">Returns all log lines from streams that have both labels.</div>\n        </div>\n\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Filtering for search terms.</div>\n          {this.renderExpression('{app=\"cassandra\"} |~ \"(duration|latency)s*(=|is|of)s*[d.]+\"')}\n          {this.renderExpression('{app=\"cassandra\"} |= \"exact match\"')}\n          {this.renderExpression('{app=\"cassandra\"} != \"do not match\"')}\n          <div className=\"cheat-sheet-item__label\">\n            <a href=\"https://grafana.com/docs/loki/latest/logql/#log-pipeline\" target=\"logql\">\n              LogQL\n            </a>{' '}\n            supports exact and regular expression filters.\n          </div>\n        </div>\n        {LOGQL_EXAMPLES.map((item) => (\n          <div className=\"cheat-sheet-item\" key={item.expression}>\n            <div className=\"cheat-sheet-item__title\">{item.title}</div>\n            {this.renderExpression(item.expression)}\n            <div className=\"cheat-sheet-item__label\">{item.label}</div>\n          </div>\n        ))}\n      </div>\n    );\n  }\n}\n","// Libraries\nimport React, { memo } from 'react';\n\n// Types\nimport { QueryEditorProps } from '@grafana/data';\nimport { LokiDatasource } from '../datasource';\nimport { LokiQuery, LokiOptions } from '../types';\nimport { LokiQueryField } from './LokiQueryField';\nimport { LokiOptionFields } from './LokiOptionFields';\n\ntype Props = QueryEditorProps<LokiDatasource, LokiQuery, LokiOptions>;\n\nexport function LokiExploreQueryEditor(props: Props) {\n  const { query, data, datasource, history, onChange, onRunQuery, range } = props;\n\n  return (\n    <LokiQueryField\n      datasource={datasource}\n      query={query}\n      onChange={onChange}\n      onBlur={() => {}}\n      onRunQuery={onRunQuery}\n      history={history}\n      data={data}\n      range={range}\n      ExtraFieldElement={\n        <LokiOptionFields\n          queryType={query.instant ? 'instant' : 'range'}\n          lineLimitValue={query?.maxLines?.toString() || ''}\n          resolution={query.resolution || 1}\n          query={query}\n          onRunQuery={onRunQuery}\n          onChange={onChange}\n        />\n      }\n    />\n  );\n}\n\nexport default memo(LokiExploreQueryEditor);\n","// Libraries\nimport React from 'react';\n\n// Types\nimport { InlineFormLabel } from '@grafana/ui';\nimport { LokiQueryField } from './LokiQueryField';\nimport { LokiOptionFields } from './LokiOptionFields';\nimport { LokiQueryEditorProps } from './types';\n\nexport function LokiQueryEditor(props: LokiQueryEditorProps) {\n  const { query, data, datasource, onChange, onRunQuery, range } = props;\n\n  const onLegendChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const nextQuery = { ...query, legendFormat: e.currentTarget.value };\n    onChange(nextQuery);\n  };\n\n  const legendField = (\n    <div className=\"gf-form-inline\">\n      <div className=\"gf-form\">\n        <InlineFormLabel\n          width={6}\n          tooltip=\"Controls the name of the time series, using name or pattern. For example\n        {{hostname}} will be replaced with label value for the label hostname. The legend only applies to metric queries.\"\n        >\n          Legend\n        </InlineFormLabel>\n        <input\n          type=\"text\"\n          className=\"gf-form-input\"\n          placeholder=\"legend format\"\n          value={query.legendFormat || ''}\n          onChange={onLegendChange}\n          onBlur={onRunQuery}\n        />\n      </div>\n    </div>\n  );\n\n  return (\n    <LokiQueryField\n      datasource={datasource}\n      query={query}\n      onChange={onChange}\n      onRunQuery={onRunQuery}\n      onBlur={onRunQuery}\n      history={[]}\n      data={data}\n      data-testid={testIds.editor}\n      range={range}\n      ExtraFieldElement={\n        <>\n          <LokiOptionFields\n            queryType={query.instant ? 'instant' : 'range'}\n            lineLimitValue={query?.maxLines?.toString() || ''}\n            resolution={query?.resolution || 1}\n            query={query}\n            onRunQuery={onRunQuery}\n            onChange={onChange}\n            runOnBlur={true}\n          />\n          {legendField}\n        </>\n      }\n    />\n  );\n}\n\nexport const testIds = {\n  editor: 'loki-editor',\n};\n","import React from 'react';\nimport { LokiQueryField } from './LokiQueryField';\nimport { LokiQueryEditorProps } from './types';\n\nexport function LokiQueryEditorForAlerting(props: LokiQueryEditorProps) {\n  const { query, data, datasource, onChange, onRunQuery } = props;\n\n  return (\n    <LokiQueryField\n      datasource={datasource}\n      query={query}\n      onChange={onChange}\n      onRunQuery={onRunQuery}\n      onBlur={onRunQuery}\n      history={[]}\n      data={data}\n      placeholder=\"Enter a Loki query\"\n      data-testid={testIds.editor}\n    />\n  );\n}\n\nexport const testIds = {\n  editor: 'loki-editor-cloud-alerting',\n};\n","import React, { memo } from 'react';\nimport { CoreApp } from '@grafana/data';\nimport { LokiQueryEditorProps } from './types';\nimport { LokiQueryEditor } from './LokiQueryEditor';\nimport { LokiQueryEditorForAlerting } from './LokiQueryEditorForAlerting';\n\nexport function LokiQueryEditorByApp(props: LokiQueryEditorProps) {\n  const { app } = props;\n\n  switch (app) {\n    case CoreApp.CloudAlerting:\n      return <LokiQueryEditorForAlerting {...props} />;\n    default:\n      return <LokiQueryEditor {...props} />;\n  }\n}\n\nexport default memo(LokiQueryEditorByApp);\n","import { LokiQuery } from './types';\n/**\n * Just a simple wrapper for a react component that is actually implementing the query editor.\n */\nexport class LokiAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n  declare annotation: any;\n\n  /** @ngInject */\n  constructor($scope: any) {\n    this.annotation = $scope.ctrl.annotation;\n    this.annotation.target = this.annotation.target || {};\n    this.onQueryChange = this.onQueryChange.bind(this);\n  }\n\n  onQueryChange(query: LokiQuery) {\n    this.annotation.expr = query.expr;\n    this.annotation.maxLines = query.maxLines;\n    this.annotation.instant = query.instant;\n  }\n}\n","import React from 'react';\nimport { LegacyForms } from '@grafana/ui';\nconst { FormField } = LegacyForms;\n\ntype Props = {\n  value: string;\n  onChange: (value: string) => void;\n};\n\nexport const MaxLinesField = (props: Props) => {\n  const { value, onChange } = props;\n  return (\n    <FormField\n      label=\"Maximum lines\"\n      labelWidth={11}\n      inputWidth={20}\n      inputEl={\n        <input\n          type=\"number\"\n          className=\"gf-form-input width-8 gf-form-input--has-help-icon\"\n          value={value}\n          onChange={(event) => onChange(event.currentTarget.value)}\n          spellCheck={false}\n          placeholder=\"1000\"\n        />\n      }\n      tooltip={\n        <>\n          Loki queries must contain a limit of the maximum number of lines returned (default: 1000). Increase this limit\n          to have a bigger result set for ad-hoc analysis. Decrease this limit if your browser becomes sluggish when\n          displaying the log results.\n        </>\n      }\n    />\n  );\n};\n","import React, { useEffect, useState } from 'react';\nimport { css } from '@emotion/css';\nimport { Button, DataLinkInput, stylesFactory, LegacyForms } from '@grafana/ui';\nimport { VariableSuggestion } from '@grafana/data';\nimport { DataSourcePicker } from '@grafana/runtime';\nimport { DerivedFieldConfig } from '../types';\nimport { usePrevious } from 'react-use';\n\nconst { Switch, FormField } = LegacyForms;\n\nconst getStyles = stylesFactory(() => ({\n  row: css`\n    display: flex;\n    align-items: baseline;\n  `,\n  nameField: css`\n    flex: 2;\n  `,\n  regexField: css`\n    flex: 3;\n  `,\n  urlField: css`\n    flex: 1;\n  `,\n  urlDisplayLabelField: css`\n    flex: 1;\n  `,\n}));\n\ntype Props = {\n  value: DerivedFieldConfig;\n  onChange: (value: DerivedFieldConfig) => void;\n  onDelete: () => void;\n  suggestions: VariableSuggestion[];\n  className?: string;\n};\nexport const DerivedField = (props: Props) => {\n  const { value, onChange, onDelete, suggestions, className } = props;\n  const styles = getStyles();\n  const [showInternalLink, setShowInternalLink] = useState(!!value.datasourceUid);\n  const previousUid = usePrevious(value.datasourceUid);\n\n  // Force internal link visibility change if uid changed outside of this component.\n  useEffect(() => {\n    if (!previousUid && value.datasourceUid && !showInternalLink) {\n      setShowInternalLink(true);\n    }\n    if (previousUid && !value.datasourceUid && showInternalLink) {\n      setShowInternalLink(false);\n    }\n  }, [previousUid, value.datasourceUid, showInternalLink]);\n\n  const handleChange = (field: keyof typeof value) => (event: React.ChangeEvent<HTMLInputElement>) => {\n    onChange({\n      ...value,\n      [field]: event.currentTarget.value,\n    });\n  };\n\n  return (\n    <div className={className}>\n      <div className={styles.row}>\n        <FormField\n          className={styles.nameField}\n          labelWidth={5}\n          // A bit of a hack to prevent using default value for the width from FormField\n          inputWidth={null}\n          label=\"Name\"\n          type=\"text\"\n          value={value.name}\n          onChange={handleChange('name')}\n        />\n        <FormField\n          className={styles.regexField}\n          inputWidth={null}\n          label=\"Regex\"\n          type=\"text\"\n          value={value.matcherRegex}\n          onChange={handleChange('matcherRegex')}\n          tooltip={\n            'Use to parse and capture some part of the log message. You can use the captured groups in the template.'\n          }\n        />\n        <Button\n          variant=\"destructive\"\n          title=\"Remove field\"\n          icon=\"times\"\n          onClick={(event) => {\n            event.preventDefault();\n            onDelete();\n          }}\n          className={css`\n            margin-left: 8px;\n          `}\n        />\n      </div>\n\n      <div className={styles.row}>\n        <FormField\n          label={showInternalLink ? 'Query' : 'URL'}\n          inputEl={\n            <DataLinkInput\n              placeholder={showInternalLink ? '${__value.raw}' : 'http://example.com/${__value.raw}'}\n              value={value.url || ''}\n              onChange={(newValue) =>\n                onChange({\n                  ...value,\n                  url: newValue,\n                })\n              }\n              suggestions={suggestions}\n            />\n          }\n          className={styles.urlField}\n        />\n        <FormField\n          className={styles.urlDisplayLabelField}\n          inputWidth={null}\n          label=\"URL Label\"\n          type=\"text\"\n          value={value.urlDisplayLabel}\n          onChange={handleChange('urlDisplayLabel')}\n          tooltip={'Use to override the button label when this derived field is found in a log.'}\n        />\n      </div>\n\n      <div className={styles.row}>\n        <Switch\n          label=\"Internal link\"\n          checked={showInternalLink}\n          onChange={() => {\n            if (showInternalLink) {\n              onChange({\n                ...value,\n                datasourceUid: undefined,\n              });\n            }\n            setShowInternalLink(!showInternalLink);\n          }}\n        />\n\n        {showInternalLink && (\n          <DataSourcePicker\n            tracing={true}\n            onChange={(ds) =>\n              onChange({\n                ...value,\n                datasourceUid: ds.uid,\n              })\n            }\n            current={value.datasourceUid}\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n","import React, { useState } from 'react';\nimport { css } from '@emotion/css';\nimport cx from 'classnames';\nimport { LegacyForms } from '@grafana/ui';\nconst { FormField } = LegacyForms;\nimport { DerivedFieldConfig } from '../types';\nimport { ArrayVector, Field, FieldType, LinkModel } from '@grafana/data';\nimport { getFieldLinksForExplore } from '../../../../features/explore/utils/links';\n\ntype Props = {\n  derivedFields?: DerivedFieldConfig[];\n  className?: string;\n};\nexport const DebugSection = (props: Props) => {\n  const { derivedFields, className } = props;\n  const [debugText, setDebugText] = useState('');\n\n  let debugFields: DebugField[] = [];\n  if (debugText && derivedFields) {\n    debugFields = makeDebugFields(derivedFields, debugText);\n  }\n\n  return (\n    <div className={className}>\n      <FormField\n        labelWidth={12}\n        label={'Debug log message'}\n        inputEl={\n          <textarea\n            placeholder={'Paste an example log line here to test the regular expressions of your derived fields'}\n            className={cx(\n              'gf-form-input gf-form-textarea',\n              css`\n                width: 100%;\n              `\n            )}\n            value={debugText}\n            onChange={(event) => setDebugText(event.currentTarget.value)}\n          />\n        }\n      />\n      {!!debugFields.length && <DebugFields fields={debugFields} />}\n    </div>\n  );\n};\n\ntype DebugFieldItemProps = {\n  fields: DebugField[];\n};\nconst DebugFields = ({ fields }: DebugFieldItemProps) => {\n  return (\n    <table className={'filter-table'}>\n      <thead>\n        <tr>\n          <th>Name</th>\n          <th>Value</th>\n          <th>Url</th>\n        </tr>\n      </thead>\n      <tbody>\n        {fields.map((field) => {\n          let value: any = field.value;\n          if (field.error) {\n            value = field.error.message;\n          } else if (field.href) {\n            value = <a href={field.href}>{value}</a>;\n          }\n          return (\n            <tr key={`${field.name}=${field.value}`}>\n              <td>{field.name}</td>\n              <td>{value}</td>\n              <td>{field.href ? <a href={field.href}>{field.href}</a> : ''}</td>\n            </tr>\n          );\n        })}\n      </tbody>\n    </table>\n  );\n};\n\ntype DebugField = {\n  name: string;\n  error?: any;\n  value?: string;\n  href?: string;\n};\n\nfunction makeDebugFields(derivedFields: DerivedFieldConfig[], debugText: string): DebugField[] {\n  return derivedFields\n    .filter((field) => field.name && field.matcherRegex)\n    .map((field) => {\n      try {\n        const testMatch = debugText.match(field.matcherRegex);\n        const value = testMatch && testMatch[1];\n        let link: LinkModel<Field> | null = null;\n\n        if (field.url && value) {\n          link = getFieldLinksForExplore({\n            field: {\n              name: '',\n              type: FieldType.string,\n              values: new ArrayVector([value]),\n              config: {\n                links: [{ title: '', url: field.url }],\n              },\n            },\n            rowIndex: 0,\n            range: {} as any,\n          })[0];\n        }\n\n        return {\n          name: field.name,\n          value: value || '<no match>',\n          href: link && link.href,\n        } as DebugField;\n      } catch (error) {\n        return {\n          name: field.name,\n          error,\n        } as DebugField;\n      }\n    });\n}\n","import React, { useState } from 'react';\nimport { css } from '@emotion/css';\nimport { Button, useTheme2 } from '@grafana/ui';\nimport { GrafanaTheme2, VariableOrigin, DataLinkBuiltInVars } from '@grafana/data';\nimport { DerivedFieldConfig } from '../types';\nimport { DerivedField } from './DerivedField';\nimport { DebugSection } from './DebugSection';\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  infoText: css`\n    padding-bottom: ${theme.spacing(2)};\n    color: ${theme.colors.text.secondary};\n  `,\n  derivedField: css`\n    margin-bottom: ${theme.spacing(1)};\n  `,\n});\n\ntype Props = {\n  value?: DerivedFieldConfig[];\n  onChange: (value: DerivedFieldConfig[]) => void;\n};\n\nexport const DerivedFields = (props: Props) => {\n  const { value, onChange } = props;\n  const theme = useTheme2();\n  const styles = getStyles(theme);\n\n  const [showDebug, setShowDebug] = useState(false);\n\n  return (\n    <>\n      <h3 className=\"page-heading\">Derived fields</h3>\n\n      <div className={styles.infoText}>\n        Derived fields can be used to extract new fields from a log message and create a link from its value.\n      </div>\n\n      <div className=\"gf-form-group\">\n        {value &&\n          value.map((field, index) => {\n            return (\n              <DerivedField\n                className={styles.derivedField}\n                key={index}\n                value={field}\n                onChange={(newField) => {\n                  const newDerivedFields = [...value];\n                  newDerivedFields.splice(index, 1, newField);\n                  onChange(newDerivedFields);\n                }}\n                onDelete={() => {\n                  const newDerivedFields = [...value];\n                  newDerivedFields.splice(index, 1);\n                  onChange(newDerivedFields);\n                }}\n                suggestions={[\n                  {\n                    value: DataLinkBuiltInVars.valueRaw,\n                    label: 'Raw value',\n                    documentation: 'Exact string captured by the regular expression',\n                    origin: VariableOrigin.Value,\n                  },\n                ]}\n              />\n            );\n          })}\n        <div>\n          <Button\n            variant=\"secondary\"\n            className={css`\n              margin-right: 10px;\n            `}\n            icon=\"plus\"\n            onClick={(event) => {\n              event.preventDefault();\n              const newDerivedFields = [...(value || []), { name: '', matcherRegex: '' }];\n              onChange(newDerivedFields);\n            }}\n          >\n            Add\n          </Button>\n\n          {value && value.length > 0 && (\n            <Button variant=\"secondary\" type=\"button\" onClick={() => setShowDebug(!showDebug)}>\n              {showDebug ? 'Hide example log message' : 'Show example log message'}\n            </Button>\n          )}\n        </div>\n      </div>\n\n      {showDebug && (\n        <div className=\"gf-form-group\">\n          <DebugSection\n            className={css`\n              margin-bottom: 10px;\n            `}\n            derivedFields={value}\n          />\n        </div>\n      )}\n    </>\n  );\n};\n","import React from 'react';\nimport { DataSourcePluginOptionsEditorProps, DataSourceSettings } from '@grafana/data';\nimport { AlertingSettings, DataSourceHttpSettings } from '@grafana/ui';\nimport { LokiOptions } from '../types';\nimport { MaxLinesField } from './MaxLinesField';\nimport { DerivedFields } from './DerivedFields';\nimport { getAllAlertmanagerDataSources } from 'app/features/alerting/unified/utils/alertmanager';\n\nexport type Props = DataSourcePluginOptionsEditorProps<LokiOptions>;\n\nconst makeJsonUpdater = <T extends any>(field: keyof LokiOptions) => (\n  options: DataSourceSettings<LokiOptions>,\n  value: T\n): DataSourceSettings<LokiOptions> => {\n  return {\n    ...options,\n    jsonData: {\n      ...options.jsonData,\n      [field]: value,\n    },\n  };\n};\n\nconst setMaxLines = makeJsonUpdater('maxLines');\nconst setDerivedFields = makeJsonUpdater('derivedFields');\n\nexport const ConfigEditor = (props: Props) => {\n  const { options, onOptionsChange } = props;\n  const alertmanagers = getAllAlertmanagerDataSources();\n\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl={'http://localhost:3100'}\n        dataSourceConfig={options}\n        showAccessOptions={false}\n        onChange={onOptionsChange}\n      />\n\n      <AlertingSettings<LokiOptions>\n        alertmanagerDataSources={alertmanagers}\n        options={options}\n        onOptionsChange={onOptionsChange}\n      />\n\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <MaxLinesField\n              value={options.jsonData.maxLines || ''}\n              onChange={(value) => onOptionsChange(setMaxLines(options, value))}\n            />\n          </div>\n        </div>\n      </div>\n\n      <DerivedFields\n        value={options.jsonData.derivedFields}\n        onChange={(value) => onOptionsChange(setDerivedFields(options, value))}\n      />\n    </>\n  );\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport Datasource from './datasource';\n\nimport LokiCheatSheet from './components/LokiCheatSheet';\nimport LokiExploreQueryEditor from './components/LokiExploreQueryEditor';\nimport LokiQueryEditorByApp from './components/LokiQueryEditorByApp';\nimport { LokiAnnotationsQueryCtrl } from './LokiAnnotationsQueryCtrl';\nimport { ConfigEditor } from './configuration/ConfigEditor';\n\nexport const plugin = new DataSourcePlugin(Datasource)\n  .setQueryEditor(LokiQueryEditorByApp)\n  .setConfigEditor(ConfigEditor)\n  .setExploreQueryField(LokiExploreQueryEditor)\n  .setQueryEditorHelp(LokiCheatSheet)\n  .setAnnotationQueryCtrl(LokiAnnotationsQueryCtrl);\n"],"names":["uuid","validate","TypeError","v","arr","Uint8Array","parseInt","slice","f","s","x","y","z","ROTL","n","v5","name","version","hashfunc","generateUUID","value","namespace","buf","offset","str","unescape","encodeURIComponent","bytes","i","length","push","charCodeAt","stringToBytes","set","stringify","err","DNS","URL","v35","K","H","msg","Array","isArray","prototype","call","l","N","Math","ceil","M","_i","Uint32Array","j","pow","floor","_i2","W","t","_t","a","b","c","d","e","_t2","T","formatQuery","selector","trim","getHighlighterExpressionsFromQuery","input","expression","results","filterStart","search","filterOperator","substr","skip","filterEnd","filterTerm","quotedTerm","match","backtickedTerm","term","unwrappedFilterTerm","replace","escapeRegExp","LokiResultType","lokiStreamResultToDataFrame","stream","reverse","refId","labels","labelsString","Object","entries","map","key","val","sort","join","times","ArrayVector","timesNs","lines","uids","usedUids","ts","line","values","add","Date","toISOString","createUid","dataFrame","fields","type","FieldType","config","displayName","mutableDataFrame","MutableDataFrame","constructDataFrame","id","uuidv5","newCount","lokiMatrixToTimeSeries","matrixResult","options","labelData","label","undefined","isEmpty","legendFormat","metricName","__name__","labelPart","getOriginalMetricName","aliasPattern","aliasData","aliasRegex","_","g1","renderTemplate","getTemplateSrv","scopedVars","query","createMetricLabel","metric","target","title","datapoints","lokiPointsToTimeseriesPoints","tags","meta","data","stepMs","step","baseTimestampMs","start","time","datapointValue","parseFloat","isNaN","timestamp","endTimestamp","end","lokiResultsToTableModel","lokiResults","resultCount","valueWithRefId","TableModel","sortedLabels","Set","reduce","acc","cur","concat","keys","table","columns","text","filterable","forEach","series","newSeries","rows","lokiStatsToMetaStat","stats","result","section","unit","test","capitalize","m","toLowerCase","lokiStreamsToDataFrames","response","limit","custom","lokiQueryStatKey","searchWords","expr","preferredVisualisationType","enhanceDataFrame","some","error","derivedFields","derivedFieldsGrouped","groupBy","newFields","fieldFromDerivedFieldConfig","DataFrameView","row","field","logMatch","matcherRegex","derivedFieldConfigs","dataSourceSrv","getDataSourceSrv","dataLinks","derivedFieldConfig","datasourceUid","dsSettings","getInstanceSettings","urlDisplayLabel","url","internal","datasourceName","links","rangeQueryResponseToTimeSeries","responseListLength","transformerOptions","format","resultType","Vector","vecResult","Matrix","processRangeQueryResponse","Stream","of","Error","DEFAULT_WEBSOCKET_CONFIG","deserializer","JSON","parse","serializer","WebSocketSubject","_super","urlConfigOrSource","destination","_this","this","_socket","Observable","source","_config","_output","Subject","hasOwnProperty","WebSocketCtor","WebSocket","ReplaySubject","lift","operator","sock","_resetState","multiplex","subMsg","unsubMsg","messageFilter","self","observer","next","subscription","subscribe","complete","unsubscribe","_connectSocket","_a","protocol","binaryType","socket","Subscription","readyState","close","onopen","evt","openObserver","queue","Subscriber","send","closingObserver","code","reason","onerror","onclose","closeObserver","wasClean","onmessage","_subscribe","subscriber","observers","LiveStreams","getStream","retryInterval","streams","CircularDataFrame","capacity","size","addField","parseLabels","pipe","baseLabels","tsField","tsNsField","lineField","labelsField","idField","unique","findUniqueLabels","allLabelsString","appendResponseToBufferedData","retryWhen","attempts","mergeMap","retryAttempt","console","warn","timer","throwError","finalize","GRAPHITE_TO_LOKI_OPERATOR","fromGraphite","graphiteQuery","matchingFound","seriesByTagUsed","tag","targetNodes","segments","segment","mappings","filter","mapping","matchers","every","matcher","index","labelName","converted","includes","pairs","DEFAULT_KEYS","EMPTY_SELECTOR","RATE_RANGES","sortValue","wrapLabel","filterText","LokiLanguageProvider","LanguageProvider","constructor","datasource","initialValues","super","LRU","async","params","metadataRequest","startTask","fetchLabels","then","started","context","suggestions","getEmptyCompletionItems","getTermCompletionItems","prefixMatch","items","FUNCTIONS","suggestion","kind","PIPE_OPERATORS","PIPE_PARSERS","getTimeRangeParams","cacheKey","generateCacheKey","seriesCache","get","request","processLabels","labelKeys","labelFetchTs","assign","getSyntax","syntax","getLabelKeys","wrapperClasses","prefix","emptyResult","empty","document","selectedLines","getTextsAtRange","selection","currentLine","first","getText","nextCharacter","anchor","tokenRecognized","prefixUnrecognized","noSuffix","safePrefix","isNextOperand","getRangeCompletionItems","getLabelCompletionItems","getPipeCompletionItem","getBeginningCompletionItems","history","historyItems","chain","h","uniq","take","item","cutoffTs","now","historyForItem","hint","recent","dateTime","fromNow","documentation","addHistoryMetadata","skipSort","labelKey","anchorBlock","cursorOffset","isValueStart","parsedSelector","parseSelector","existingKeys","labelValues","getLabelValues","getSeriesLabels","possibleKeys","difference","newSuggestion","queries","originDataSource","datasourceType","Promise","all","importPrometheusQuery","range","graphiteDataSource","model","GraphiteQueryModel","textEditor","parseTarget","getImportQueryConfiguration","loki","selectorMatch","selectorRegexp","labelRegexp","labelsToKeep","lookupsDisabled","fetchSeriesLabels","timeRange","valueOf","res","forceRefresh","param","roundTime","nanos","fetchLabelValues","rangeParams","labelsCache","NS_IN_MS","RANGE_QUERY_ENDPOINT","INSTANT_QUERY_ENDPOINT","DEFAULT_QUERY_PARAMS","direction","LokiDatasource","DataSourceApi","instanceSettings","templateSrv","timeSrv","getTimeSrv","timeNs","getTime","to","queryLimit","isMetricsQuery","maxDataPoints","maxLines","min","Infinity","_request","jsonData","catchError","processError","liveStreaming","runLiveQuery","createRangeQuery","headers","volumeQuery","switchMap","liveTarget","createLiveTarget","state","LoadingState","prepareLogRowContextQueryTarget","lastValueFrom","message","status","statusText","languageProvider","contextTimeBuffer","commonTargetOptions","nsTimestamp","FieldCache","getFieldByName","rowIndex","timeEpochMs","settingsData","apiUrl","baseUrl","serializeParams","withCredentials","basicAuth","Authorization","req","getBackendSrv","fetch","getLogsVolumeDataProvider","targets","logsVolumeRequest","cloneDeep","instant","queryLogsVolume","timeout","extractLevel","subQueries","getRangeScopedVars","filteredTargets","hide","addAdHocFilters","interpolateQueryExpr","runInstantQuery","runRangeQuery","merge","startNs","from","endNs","rangeMs","resolution","DEFAULT_RESOLUTION","adjustedInterval","adjustInterval","intervalMs","convertToWebSocketUrl","msRange","diff","sRange","round","__range_ms","__range_s","__range","interpolateVariablesInQueries","expandedQueries","getRef","getQueryDisplayText","importQueries","hideFromInspector","resolve","interpolated","processMetricFindQuery","labelNamesQuery","labelValuesSeriesQuery","labelValuesQuery","timeParams","variable","multi","includeAll","lokiRegularEscape","lokiSpecialRegexEscape","lodashMap","modifyQuery","action","addLabelToQuery","date","roundUp","dateMath","testDatasource","stepInterval","tagKeys","titleFormat","textFormat","annotation","interpolatedExpr","annotations","splitKeys","split","frame","String","apply","showContextToggle","dynamicInterval","safeInterval","max","queryExpr","getAdhocFilters","parsers","parser","RegExp","queryHasPipeParser","toString","addParsedLabelToQuery","_match","Prism","valueField","getFirstFieldOfType","labelNames","levelLabel","getLogLevelFromKey","LogLevel","getLogLevelFromLabels","DEFAULT_EXAMPLES","PREFERRED_LABELS","LOGQL_EXAMPLES","LokiCheatSheet","PureComponent","userExamples","provider","props","preferredLabel","find","shuffle","setState","scheduleUserLabelChecking","componentDidMount","componentWillUnmount","clearTimeout","userLabelTimer","setTimeout","checkUserLabels","renderExpression","onClickExample","className","onClick","render","hasUserExamples","example","href","LokiExploreQueryEditor","onChange","onRunQuery","LokiQueryField","onBlur","ExtraFieldElement","LokiOptionFields","queryType","lineLimitValue","memo","LokiQueryEditor","legendField","InlineFormLabel","width","tooltip","placeholder","nextQuery","currentTarget","testIds","editor","runOnBlur","LokiQueryEditorForAlerting","LokiQueryEditorByApp","app","CoreApp","LokiAnnotationsQueryCtrl","$scope","ctrl","onQueryChange","bind","FormField","LegacyForms","MaxLinesField","labelWidth","inputWidth","inputEl","event","spellCheck","Switch","getStyles","stylesFactory","css","nameField","regexField","urlField","urlDisplayLabelField","DerivedField","onDelete","styles","showInternalLink","setShowInternalLink","useState","previousUid","usePrevious","useEffect","handleChange","Button","variant","icon","preventDefault","DataLinkInput","newValue","checked","DataSourcePicker","tracing","ds","uid","current","DebugSection","debugText","setDebugText","debugFields","testMatch","link","getFieldLinksForExplore","makeDebugFields","cx","DebugFields","DerivedFields","theme","infoText","spacing","colors","secondary","derivedField","useTheme2","showDebug","setShowDebug","newField","newDerivedFields","splice","DataLinkBuiltInVars","origin","VariableOrigin","makeJsonUpdater","setMaxLines","setDerivedFields","plugin","DataSourcePlugin","Datasource","setQueryEditor","setConfigEditor","onOptionsChange","alertmanagers","getAllAlertmanagerDataSources","DataSourceHttpSettings","defaultUrl","dataSourceConfig","showAccessOptions","AlertingSettings","alertmanagerDataSources","setExploreQueryField","setQueryEditorHelp","setAnnotationQueryCtrl"],"sourceRoot":""}